<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KentonYu&#39;s Blog</title>
  <subtitle>To Be A Full Stack Developer !</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2016-08-29T16:38:34.000Z</updated>
  <id>/</id>
  
  <author>
    <name>Kenton Yu</name>
    <email>KentonYu@KentonYu.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊聊 60 分的 Web API</title>
    <link href="/2016/08/30/%E8%81%8A%E8%81%8A%2060%20%E5%88%86%E7%9A%84%20Web%20API/"/>
    <id>/2016/08/30/聊聊 60 分的 Web API/</id>
    <published>2016-08-29T16:30:01.000Z</published>
    <updated>2016-08-29T16:38:34.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;扯-dan&quot;&gt;&lt;a href=&quot;#扯-dan&quot; class=&quot;headerlink&quot; title=&quot;扯 dan&quot;&gt;&lt;/a&gt;扯 dan&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;应用程序接口（英语：Application Programming Interface，简称：API），又称为应用编程接口，就是软件系统不同组成部分衔接的约定。由于近年来软件的规模日益庞大，常常需要把复杂的系统划分成小的组成部分，编程接口的设计十分重要。程序设计的实践中，编程接口的设计首先要使软件系统的职责得到合理划分。良好的接口设计可以降低系统各部分的相互依赖，提高组成单元的内聚性，降低组成单元间的耦合程度，从而提高系统的维护性和扩展性。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是 WiKi 对 API 的描述，日常开发中笔者通常以 API（接口） 来狭义地指代 Web API（Web Service）。当然这种现象可能只存在于移动互联网行业里（甚至 Only me ？有其它称呼可以留言哦），毕竟人家做硬件也会提供 API 。反正下文中笔者以 API 来指代 Web API ，少按 5 次键盘 🕵。&lt;br&gt;聊聊 60 分的 Web API ，这个 Topic 其实也是笔者 YY 出来的，实在是墨水有限。为何只是“聊聊 60 分的”，笔者认怂，自认只了解 60 分的水平（实际 30？及格分总要给吧 😳），希望大 🐂🐂 能不吝指导一二。接下来笔者会先简单描述下了解的三种 API 类型，然后再写下对于 60 分 API 应该具有的“素质”。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;h4 id=&quot;API-风格&quot;&gt;&lt;a href=&quot;#API-风格&quot; class=&quot;headerlink&quot; title=&quot;API 风格&quot;&gt;&lt;/a&gt;API 风格&lt;/h4&gt;&lt;p&gt;笔者了解到的 API 协议/架构风格主要有三种 —— RPC &amp;amp; SOAP &amp;amp; REST。  其中对于 RPC 和 SOAP 协议了解不够深入，下文着重描述 REST。 &lt;/p&gt;
&lt;h5 id=&quot;RPC&quot;&gt;&lt;a href=&quot;#RPC&quot; class=&quot;headerlink&quot; title=&quot;RPC&quot;&gt;&lt;/a&gt;RPC&lt;/h5&gt;&lt;p&gt;RPC，Remote Procedure Call 是一种计算机编程协议，该协议允许一套计算机调用另一台计算机上的子程序。RPC 定义了结构化的 Request 和 Response，以 GET 、POST 作为主要请求方法。请求数据格式可以是 XML，也支持更轻量的 JSON。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// XML RPC Request
&amp;lt;?xml version = &amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;methodCall&amp;gt;
    &amp;lt;methodName&amp;gt;getUserName&amp;lt;/methodName&amp;gt;
    &amp;lt;params&amp;gt;
        &amp;lt;param&amp;gt;
            &amp;lt;value&amp;gt;
                &amp;lt;id&amp;gt;40&amp;lt;/id&amp;gt;
            &amp;lt;/value&amp;gt;
        &amp;lt;/param&amp;gt;
    &amp;lt;/params&amp;gt;
&amp;lt;/methodCall&amp;gt;

// XML RPC Response
&amp;lt;?xml version = &amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;methodResponse&amp;gt;
    &amp;lt;params&amp;gt;
         &amp;lt;param&amp;gt;
            &amp;lt;value&amp;gt;
                &amp;lt;string&amp;gt;KentonYu&amp;lt;/string&amp;gt;
            &amp;lt;/value&amp;gt;
        &amp;lt;/param&amp;gt;
    &amp;lt;/params&amp;gt;
&amp;lt;/methodResponse&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;SOAP&quot;&gt;&lt;a href=&quot;#SOAP&quot; class=&quot;headerlink&quot; title=&quot;SOAP&quot;&gt;&lt;/a&gt;SOAP&lt;/h5&gt;&lt;p&gt;SOAP，Simple Object Access Protocol 是 Web Service 交换数据的一种协议，基于 XML-RPC 进行优化修改。它不仅支持 HTTP/HTTPS，还支持 SMTP 协议。它比 XML-RPC 更强大，但是数据格式只支持 XML。&lt;br&gt;&lt;img src=&quot;http://7xtamz.com1.z0.glb.clouddn.com/SOAP.png&quot; alt=&quot;SOAP XML 请求格式&quot; title=&quot;SOAP XML 请求格式&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;REST&quot;&gt;&lt;a href=&quot;#REST&quot; class=&quot;headerlink&quot; title=&quot;REST&quot;&gt;&lt;/a&gt;REST&lt;/h5&gt;&lt;p&gt;REST，Representational State Transfer（表述性状态转移）是一种架构风格，而不是协议。它是 Roy Thomas Fielding 博士于 2000 年在他的博士论文 “Architectural Styles and the Design of Network-based Software Architectures” 中提出来的，但是在 5 年后才开始受到关注。REST 通常基于 HTTP，URI 以及 JSON、XML 等协议和标准实现。当 REST 风格应用在 API 上时，我们称之为 RESTful API。&lt;br&gt;REST 并没有具体的规范，它只是一种风格。何为风格？提供一系列约束，但是不强制性要求必须满足这些约束。&lt;br&gt;REST 架构风格的形成，主要遵循了以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关注点分离；&lt;/li&gt;
&lt;li&gt;可见性、可靠性和可伸缩性；&lt;/li&gt;
&lt;li&gt;网络性能、效率；&lt;/li&gt;
&lt;li&gt;统一接口；&lt;br&gt;总得来说，REST 是为了让 Web 服务更加高效、可靠、通用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;相对于 RPC（面向动作）、SOAP（消息机制），REST 是面向资源。资源，可以是服务器数据库的一张表，一张图片，或者说更加抽象的东西（当然这个东西要便于客户端开发理解）。&lt;br&gt;它主要是从以下三个方面来标识资源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直观简短描述性的 URI；&lt;/li&gt;
&lt;li&gt;传输的资源格式（JSON，XML，HTML.etc.）;&lt;/li&gt;
&lt;li&gt;对资源的操作，一般通过 HTTP 的一系列请求方法来表示；&lt;br&gt;&lt;img src=&quot;http://7xtamz.com1.z0.glb.clouddn.com/REST%20HTTP%20Method.png&quot; alt=&quot;HTTP 请求方法在 RESTful API 中的典型应用&quot; title=&quot;HTTP 请求方法在 RESTful API 中的典型应用&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么 RESTful API 具体长什么样子？接下来我们就来看看 Github 的 API 设计，它是遵循 REST 风格的。&lt;br&gt;&lt;img src=&quot;http://7xtamz.com1.z0.glb.clouddn.com/Github%20RESTful%20API%201.png&quot; alt=&quot;Github API 获取用户邮箱地址&quot; title=&quot;Github API 获取用户邮箱地址&quot;&gt;&lt;br&gt;这就是一个简单的遵循 REST 的 API，使用 HTTP 的 GET 方法指出是读取服务器资源，通过 URI “/user/emails”  来定位到具体的资源。REST 是面向资源的，因此在设计 URI 时是不会出现类似 “getEmails” 这样的动词。响应结果通过状态码（Status Code）来标识，具体响应数据通过 JSON 格式传输，当然也可以使用 XML 格式，甚至 HTML。   &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtamz.com1.z0.glb.clouddn.com/Github%20RESTful%20API%202.png&quot; alt=&quot;Github API 添加用户邮箱地址&quot; title=&quot;Github API 添加用户邮箱地址&quot;&gt;&lt;br&gt;增加用户邮箱地址，采用 POST 请求方法，URI 仍旧是 “/user/emails”，因为这两个 API 操作的资源都是 Emails，因此 URI 是一致的。它们通过使用的请求方法（GET、POST、PUT、DELETE .etc.）来区分不同的动作。  &lt;/p&gt;
&lt;h5 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h5&gt;&lt;p&gt;以上简略地描述了下 RPC、SOAP、REST 的概念，它们三者的目的是一致的 —— 作为客户端和服务端沟通桥梁。但是它们之间也是各有特点，比如 RPC 面向动作，SOAP 以消息作为通讯机制，REST 则面向资源。在实际开发的技术选型中，了解这三种的优劣势，在其中权衡，选择最高效、最适合的技术方案即可。当然，技术思想都是在不断发展进步的，后起之秀 REST 综合指数一定是比 RPC/SOAP 更具优势，它更适合一个新产品、新公司的技术选型，因为 REST 紧密贴合 HTTP，扩展性和兼容性更强，并且通过描述性的 URI 调用，客户端开发效率更高。&lt;/p&gt;
&lt;h4 id=&quot;60-分-API-的素质&quot;&gt;&lt;a href=&quot;#60-分-API-的素质&quot; class=&quot;headerlink&quot; title=&quot;60 分 API 的素质&quot;&gt;&lt;/a&gt;60 分 API 的素质&lt;/h4&gt;&lt;h5 id=&quot;API-的一致性&quot;&gt;&lt;a href=&quot;#API-的一致性&quot; class=&quot;headerlink&quot; title=&quot;API 的一致性&quot;&gt;&lt;/a&gt;API 的一致性&lt;/h5&gt;&lt;p&gt;一致性，大致可以分为两类：风格一致性和数据一致性。&lt;br&gt;风格一致性可能对于优化 API 的性能来说起不到实质性的作用，但是它的确可以提高团队的开发效率。如果一套 API 保持一致的风格，并且正确使用自描述性的命名，将会很大程度上提高 API 使用者的开发效率以及降低后续的维护成本。为了保持风格一致性团队必须有一份 API 规范文档来约束，这是必要的。&lt;br&gt;数据一致性主要提现在 API 的幂等性上，HTTP 的请求方法中 GET 、PUT、DELETE 应该保证是幂等的 —— 相同条件下，多次请求不会产生副作用。&lt;/p&gt;
&lt;h5 id=&quot;安全性&quot;&gt;&lt;a href=&quot;#安全性&quot; class=&quot;headerlink&quot; title=&quot;安全性&quot;&gt;&lt;/a&gt;安全性&lt;/h5&gt;&lt;p&gt;API 的安全性在整个开发过程中毋庸置疑是最重要的环节之一，一套没有安全性可言的 API 对于用户或老板来说都是不负责任的表现。因为 API 是数据和用户连接的桥梁，API 的安全性直接关系到用户信息的安全性以及整个应用的安全性。因此一个 &lt;strong&gt;60 分的 API 应该具有一定的自我保护能力&lt;/strong&gt;。 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;数据合法性验证&lt;br&gt; 记得学封装的概念时看到的一句话，大致意思是暴露的 API 都必须保证数据的合法性，因为你永远不知道调用者会传什么数据给你。对于 Web API 来讲，它更不可能知道调用者会是谁（iOS、Andriod、模拟请求工具、黑客.etc.），会传什么数据给你，因此对于每一个 API 都应该进行数据合法性验证。一次请求包括 URI QueryString、 Request Header、Body ，API 应该一步步的判定这些数据的合法性，它们之间应该是“与”的关系。&lt;br&gt; 最基础的数据验证应该做到过滤无效（或不合常理）数据，比如 API 入参有一个 age（interger） 字段，当某个请求传入 -1 时，就应该将拒绝这次不合法的请求，因为 age 不可能存在负数。&lt;br&gt; 做到以上这一步只能说保护了数据库不会被写入不符合预期的数据，但是也要考虑到一些数据符合我们的约定，但是它本身具有攻击性，比如脚本注入，SQL 注入等。这些常见的攻击手段都应该在这一环节屏蔽掉。   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据完整性验证&lt;br&gt; 请求数据需要经过网络的传输才能到达服务器端，在这过程中，API 需要确保请求数据是否完整（相对于客户端发送请求时的数据）。比如从云盘下载文件时，如果你的文件在传输过程中丢了一些包，那么这个文件将不能打开，并且这次下载是无效的。因此 API 要确保每一次请求的数据都是完整的，这可以通过请求的参数生成一个 MD5 验证字符串，在服务端验证数据完整性。&lt;br&gt; 传输过程中请求数据可能会丢包或者被修改，那么数据库中的数据也可能会被其它请求修改，因此&lt;strong&gt;修改数据库数据&lt;/strong&gt;时要确保数据的完整性，当客户端使用和数据库不一致的数据时，应该拒绝这次请求。这可以通过使用 ETag（某个资源的一个唯一的版本号，也可以用来实现 Cache ）来防止错误更新，使用 “If-Match” 头来提供客户端的 ETag，判断和服务器资源当前版本是否一致（当然高并发时会存在 A 请求正在准备写入数据库，而 B 刚进入 ETag 验证，并且恰好通过）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;API 访问控制&lt;br&gt; 对于大多数应用，它的 API 一定是不想公开被其它人使用的，尤其是竞争对手。一套合格的 API 应该具有一个合理的访问控制。目前较为普遍的是使用 HMAC 验证，通过一个密钥对请求信息进行算法处理，生成一个摘要信息，然后服务端通过同样的密钥进行处理，比对摘要信息是否一致来确定是否是合法请求。通过 HMAC 可以防止不合法的请求，并且保证数据没有受到“中间人”攻击。&lt;br&gt; 除了 HMAC，还有 OAuth、HTTP BASIC Auth 等访问控制手段，当然你也可以自定义一些逻辑算法，比如可以将请求参数按首字母排序，加上请求时间戳（请求的实时性，防止一个 Request 在不同时间里重复请求）利用 DES、3DES、AES 等对称加密算法进行加密，生成一个请求密钥，服务端通过相同的逻辑算法来比对请求密钥，从而实现访问控制。&lt;br&gt; 访问控制可以很大程度上避免 DDOS 攻击，防止服务器资源被“榨干”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;API-日志收集&quot;&gt;&lt;a href=&quot;#API-日志收集&quot; class=&quot;headerlink&quot; title=&quot;API 日志收集&quot;&gt;&lt;/a&gt;API 日志收集&lt;/h5&gt;&lt;p&gt;API 应该收集每个请求的到达时间，处理时间，请求数据，响应数据，请求客户端信息等。日志的收集，有助于解决一些 bug，对于一些 API 的性能优化，以及运营人员的分析等。&lt;/p&gt;
&lt;h5 id=&quot;丰富的-API-文档&quot;&gt;&lt;a href=&quot;#丰富的-API-文档&quot; class=&quot;headerlink&quot; title=&quot;丰富的 API 文档&quot;&gt;&lt;/a&gt;丰富的 API 文档&lt;/h5&gt;&lt;p&gt;一份丰富的 API 文档可以让客户端开发变的更加容易。把容易留给别人，那你就是佛祖，否则你就是人渣。文档中应该包含对所有 API 的一些通用描述，每个 API 都应该对应有 URI，请求头、参数，响应数据等，当然最好附带一个接口调试工具。这部分应该是服务端开发最头疼的事情了，每个 API 都要对应维护一份文档，但是目前有很多工具可以通过维护代码里的注释生成文档，从而减少开发的工作量，比如 swagger 、apidoc .etc.。&lt;/p&gt;
&lt;h5 id=&quot;其它&quot;&gt;&lt;a href=&quot;#其它&quot; class=&quot;headerlink&quot; title=&quot;其它&quot;&gt;&lt;/a&gt;其它&lt;/h5&gt;&lt;p&gt;除此之外，API 还应该支持例如 API 版本管理、事件处理回调等，具有良好的扩展性、后期可维护性等。针对安全性较高的 API，可以考虑使用 HTTPS ，在你的 API 外面再套一层壳。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;结束语&quot;&gt;&lt;a href=&quot;#结束语&quot; class=&quot;headerlink&quot; title=&quot;结束语&quot;&gt;&lt;/a&gt;结束语&lt;/h2&gt;&lt;p&gt;笔者只是通过查阅相关的文献、博客等，总结了以上的内容。如有补充，欢迎留言。希望后续开发中，能将这些一一应用，码一套 60 分的 API。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/understanding-restful-style&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;理解本真的 REST 架构风格&lt;/a&gt;（&lt;a href=&quot;http://www.infoq.com/cn/articles/understanding-restful-style）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.infoq.com/cn/articles/understanding-restful-style）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.infoq.com/resource/minibooks/web-based-apps-archit-design/zh/pdf/Fielding-PhD-thesis-on-REST.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Roy Fielding博士论文中文版&lt;/a&gt;（&lt;a href=&quot;http://www.infoq.com/resource/minibooks/web-based-apps-archit-design/zh/pdf/Fielding-PhD-thesis-on-REST.pdf）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.infoq.com/resource/minibooks/web-based-apps-archit-design/zh/pdf/Fielding-PhD-thesis-on-REST.pdf）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.github.com/v3/&quot; title=&quot;Github API v3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; Github API v3 &lt;/a&gt;（&lt;a href=&quot;https://developer.github.com/v3/）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.github.com/v3/）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/homepage?__biz=MzA3NDM0ODQwMw==&amp;amp;hid=2&amp;amp;sn=a01f85f4d8bbb41664640fa813775201&amp;amp;uin=MTkwNjIzMDE0MQ%3D%3D&amp;amp;key=8dcebf9e179c9f3a3316cbe93ab40d7e0fb364480ccc3067e1bc6e62e55d269af8e74cab47c903d518a7f63e65c2814d&amp;amp;devicetype=iPhone+OS9.3.4&amp;amp;version=16031712&amp;amp;lang=zh_CN&amp;amp;nettype=WIFI&amp;amp;fontScale=94&amp;amp;pass_ticket=EWrTRODW6mjqojfJWoSj7hEwhvI76gJmIARMBfzr0KwMpMhTvowFt2xn1pPMHp1u&amp;amp;scene=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;程序人生&lt;/a&gt;（&lt;a href=&quot;https://mp.weixin.qq.com/mp/homepage?\_\_biz=MzA3NDM0ODQwMw==&amp;amp;hid=2&amp;amp;sn=a01f85f4d8bbb41664640fa813775201&amp;amp;uin=MTkwNjIzMDE0MQ%3D%3D&amp;amp;key=8dcebf9e179c9f3a3316cbe93ab40d7e0fb364480ccc3067e1bc6e62e55d269af8e74cab47c903d518a7f63e65c2814d&amp;amp;devicetype=iPhone+OS9.3.4&amp;amp;version=16031712&amp;amp;lang=zh\_CN&amp;amp;nettype=WIFI&amp;amp;fontScale=94&amp;amp;pass\_ticket=EWrTRODW6mjqojfJWoSj7hEwhvI76gJmIARMBfzr0KwMpMhTvowFt2xn1pPMHp1u&amp;amp;scene=1）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://mp.weixin.qq.com/mp/homepage?\_\_biz=MzA3NDM0ODQwMw==&amp;amp;hid=2&amp;amp;sn=a01f85f4d8bbb41664640fa813775201&amp;amp;uin=MTkwNjIzMDE0MQ%3D%3D&amp;amp;key=8dcebf9e179c9f3a3316cbe93ab40d7e0fb364480ccc3067e1bc6e62e55d269af8e74cab47c903d518a7f63e65c2814d&amp;amp;devicetype=iPhone+OS9.3.4&amp;amp;version=16031712&amp;amp;lang=zh\_CN&amp;amp;nettype=WIFI&amp;amp;fontScale=94&amp;amp;pass\_ticket=EWrTRODW6mjqojfJWoSj7hEwhvI76gJmIARMBfzr0KwMpMhTvowFt2xn1pPMHp1u&amp;amp;scene=1）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;扯-dan&quot;&gt;&lt;a href=&quot;#扯-dan&quot; class=&quot;headerlink&quot; title=&quot;扯 dan&quot;&gt;&lt;/a&gt;扯 dan&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;应用程序接口（英语：Application Programming Interface，简
    
    </summary>
    
    
      <category term="API" scheme="/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>网络那点事 —— HTTP</title>
    <link href="/2016/08/24/%E7%BD%91%E7%BB%9C%E9%82%A3%E7%82%B9%E4%BA%8B%20%E2%80%94%E2%80%94%20HTTP/"/>
    <id>/2016/08/24/网络那点事 —— HTTP/</id>
    <published>2016-08-24T13:05:01.000Z</published>
    <updated>2016-08-24T13:33:59.000Z</updated>
    
    <content type="html">&lt;p&gt;接下来你将会花费 10 分钟左右了解到如下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP 的来世今生&lt;/li&gt;
&lt;li&gt;HTTPS 简介&lt;/li&gt;
&lt;li&gt;HTTP 请求方法介绍&lt;/li&gt;
&lt;li&gt;常见复用连接方案&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;HTTP-的来世今生&quot;&gt;&lt;a href=&quot;#HTTP-的来世今生&quot; class=&quot;headerlink&quot; title=&quot;HTTP 的来世今生&quot;&gt;&lt;/a&gt;HTTP 的来世今生&lt;/h2&gt;&lt;p&gt;HTTP（超文本传输协议），是应用最广泛的一种应用层网络协议，建立在 TCP/IP 协议簇之上，默认端口 80。目前位置一共有 4 个版本，分别是：HTTP/0.9，HTTP/1.0，HTTP/1.1，HTTP/2。其中 HTTP/0.9 版本（已过时）比较特殊，它只接受 GET 的请求方法，在请求中不指定版本号，且没有请求头。其之后的三个版本，目前都在广泛应用（HTTP/2 目前还未得到广泛普及）。接下来就一一介绍下目前在使用的三个版本的异同。&lt;/p&gt;
&lt;h4 id=&quot;HTTP-1-0&quot;&gt;&lt;a href=&quot;#HTTP-1-0&quot; class=&quot;headerlink&quot; title=&quot;HTTP/1.0&quot;&gt;&lt;/a&gt;HTTP/1.0&lt;/h4&gt;&lt;p&gt;HTTP/1.0 是第一个在请求中指定版本号的协议版本，目前主要应用在代理服务器中。支持 GET、POST、HEAD 三种请求方法。&lt;/p&gt;
&lt;h4 id=&quot;HTTP-1-1&quot;&gt;&lt;a href=&quot;#HTTP-1-1&quot; class=&quot;headerlink&quot; title=&quot;HTTP/1.1&quot;&gt;&lt;/a&gt;HTTP/1.1&lt;/h4&gt;&lt;p&gt; HTTP/1.1 继承了 HTTP/1.0 的优点，并对 HTTP/1.0 进行了性能上的优化，以及功能的扩展。主要体现在以下几点：     &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;增加 Host 域&lt;br&gt; HTTP/1.0 默认每台服务器绑定一个 IP，因此请求中只有 URI，不带 Host （可能认为建立 TCP 连接的时候指定了 IP 地址，这个 IP 已经指定了一个 Host）。但随着技术发展，一台服务器上可以部署多个服务站点并且共享一个 IP，因此 HTTP/1.1 在请求头中添加了 Host 字段（字段值可以为空，但&lt;strong&gt;字段缺失&lt;/strong&gt;会报告错误，400 Bad Request）。&lt;br&gt; &lt;img src=&quot;http://7xtamz.com1.z0.glb.clouddn.com/DraggedImage.png&quot; alt=&quot;&quot; title=&quot;HTTP/1.1 普通 GET 请求 Header&quot;&gt; &lt;/li&gt;
&lt;li&gt;持久连接（Persistent Connection）&lt;br&gt; HTTP/1.0 每一个 Request 都必须建立一个 TCP 连接，假设一个 HTML 页面里有 10 张图片，加载这个页面时，就需要建立 10 TCP 连接，这对于服务器和用户来说都是很不好的体验，当然还要考虑浏览器对并发连接数的限制和服务端对 TCP 连接数的限制，因此加载复杂页面的时候响应时间过长，资源利用率低。&lt;br&gt;HTTP/1.1 支持一个 TCP 连接可以响应多个请求，降低 TCP 的连接成本。它在请求头中增加了 Connection 字段，默认值是 Keep-Alive。当然在 HTTP/1.0 的请求头中设置 Connection:Keep-Alive 也可以实现在一段时间内复用（由服务端控制，Apache 2.0 默认 15s, Apache 2.2 默认 5s，防止因为连接保持时间过长，导致服务器资源浪费）。当然这对于 App 端来说，短时间 TCP 复用对网络请求优化效果不大。&lt;/li&gt;
&lt;li&gt;ETag（entity tag）&lt;br&gt; HTTP 协议提供的一种 Web 缓存验证机制，并且允许客户端进行缓存协商。ETag 是根据 URL 上的资源的特定版本而指定的，如果 URL 指定的资源改变了，那么新的 ETag 就会被分配。ETag 的比较只针对同一个 URL 有意义。&lt;br&gt; 以下两个 URL ETag 值的比较结果无意义，因为不是同一个 URL&lt;br&gt;  &lt;code&gt;https://www.domain.com/userInfo/1&lt;/code&gt;&lt;br&gt;  &lt;code&gt;https://www.domain.com/userInfo/2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;分块传输编码（Chunked transfer encoding）&lt;br&gt; HTTP/1.1 协议中的一种数据传输机制，允许数据分块传输。通过在 Request Header 中指明 Transfer-Encoding: chunked ，此时 Content-Length 是无效的。&lt;/li&gt;
&lt;li&gt;Range 和 Content-Range&lt;br&gt; HTTP/1.1 支持传送内容的一部分。在 Request Header 中引入了 Range，它允许只请求资源的某个部分。在 Response Header 中的 Content-Range 声明了返回的这部分对象的偏移值和长度。如果服务端返回的是请求的 Range 范围的内容，则响应码是 206（Partial Content）。利用这两个字段可以是实现断点下载。&lt;/li&gt;
&lt;li&gt;100 Status （Continue）&lt;br&gt;  HTTP/1.1 新加入了状态码 100，当 Request Body 比较大时，可以通过先发送一个只带 Header 的请求来验证权限，服务端返回 100（Continue） 时，说明可以继续请求，反之返回 401（Unauthorized）。&lt;/li&gt;
&lt;li&gt;新增请求方法&lt;br&gt; HTTP/1.1 新增支持 OPTIONS、PUT、 DELETE、 TRACE、 CONNECT 五种请求方法，后续又扩展了一些方法，其中 PATCH 使用较多。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;HTTP-2&quot;&gt;&lt;a href=&quot;#HTTP-2&quot; class=&quot;headerlink&quot; title=&quot;HTTP/2&quot;&gt;&lt;/a&gt;HTTP/2&lt;/h4&gt;&lt;p&gt;2015 年 5 月作为 HTTP 标准正式发布。主要以 Google 基于 TCP 开发的应用层协议 SPDY/3（speedy，2016 年停止维护）的技术为主。作为新版协议，细节上的改动一定很多，不过对开发者来说，影响较大的大致就以下几点：     &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;二进制格式（Binary Format）&lt;br&gt; HTTP/1.x 的请求的解析是基于文本的解析，主要由三部分组成：start line（request line），header，body。而 HTTP/2 则主要分为 Length、Type、Flags、Stream ID、Payload 五部分，Length 定义了该 frame 的开始到结束， Type 定义 frame 的类型，Flags 定义了一些重要参数， Stream ID 用作流的控制，Payload 是 Request 的正文。&lt;br&gt;  &lt;img src=&quot;http://7xtamz.com1.z0.glb.clouddn.com/DraggedImage-1.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;多路复用（MultiPlexing）&lt;br&gt;  多路复用即连接共享，二进制格式中的 Stream ID 就是用在多路复用的。一个 Request 对应一个 Stream 并分配一个 ID，这样一个连接上可以有多个 Stream，每个 Stream 的 Frame 可以随机的混合在一起，接收方可以根据 Stream ID 将 Frame 再整合到不同的 Request 里。&lt;br&gt; 连接共享会造成某些关键请求会被阻塞，因此提供了优先级（Priority）和请求依赖（Dependency）的机制。通过这两个机制，优先级高或者被依赖的 Stream 会被 Server 优先处理并响应。&lt;/li&gt;
&lt;li&gt;Request Header 压缩和缓存&lt;br&gt; HTTP/1.x 的 Header 由于 Cookie 和 User Agent 体积容易膨胀，而且每次请求都会重新发送，因此 HTTP/2 压缩 Header 的同时，服务端和客户端都会缓存一份 Request Header 表，这样既减少了体积，还避免了相同的 Header 重复发送。&lt;/li&gt;
&lt;li&gt;Server Push&lt;br&gt; HTTP/2.0 允许通过服务端推送的方式将客户端需要的内容预先推送过去。比如在用户第一次打开网站首页的时候，将必须资源主动推送到客户端，这样可以极大的提升用户体验。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;HTTP-请求方法介绍&quot;&gt;&lt;a href=&quot;#HTTP-请求方法介绍&quot; class=&quot;headerlink&quot; title=&quot;HTTP 请求方法介绍&quot;&gt;&lt;/a&gt;HTTP 请求方法介绍&lt;/h2&gt;&lt;h4 id=&quot;GET&quot;&gt;&lt;a href=&quot;#GET&quot; class=&quot;headerlink&quot; title=&quot;GET&quot;&gt;&lt;/a&gt;GET&lt;/h4&gt;&lt;p&gt;GET，幂等操作，请求会显式地请求指定的资源。一般来说 GET 方法应该只用于数据的读取。之前一直以为 GET 在 HTTP 协议中有请求长度的限制，其实 HTTP 协议并没有规定具体的长度，具体长度是由浏览器或服务器决定和设置的。&lt;/p&gt;
&lt;h4 id=&quot;HEAD&quot;&gt;&lt;a href=&quot;#HEAD&quot; class=&quot;headerlink&quot; title=&quot;HEAD&quot;&gt;&lt;/a&gt;HEAD&lt;/h4&gt;&lt;p&gt;HEAD，请求指定的资源，但是服务端响应 HEAD 请求时不会回传具体的内容（Body）。&lt;/p&gt;
&lt;h4 id=&quot;POST&quot;&gt;&lt;a href=&quot;#POST&quot; class=&quot;headerlink&quot; title=&quot;POST&quot;&gt;&lt;/a&gt;POST&lt;/h4&gt;&lt;p&gt;POST，非幂等操作，请求会向指定资源提交数据（数据包含在Request Body 中），请求服务器进行处理。如：表单处理，文件上传等。&lt;/p&gt;
&lt;h4 id=&quot;PUT&quot;&gt;&lt;a href=&quot;#PUT&quot; class=&quot;headerlink&quot; title=&quot;PUT&quot;&gt;&lt;/a&gt;PUT&lt;/h4&gt;&lt;p&gt;PUT，幂等操作，请求会向指定资源位置上传最新的内容（更新资源）。&lt;/p&gt;
&lt;h4 id=&quot;DELETE&quot;&gt;&lt;a href=&quot;#DELETE&quot; class=&quot;headerlink&quot; title=&quot;DELETE&quot;&gt;&lt;/a&gt;DELETE&lt;/h4&gt;&lt;p&gt;DELETE，幂等操作，请求服务器删除 URI 标识的资源。&lt;/p&gt;
&lt;h4 id=&quot;CONNECT&quot;&gt;&lt;a href=&quot;#CONNECT&quot; class=&quot;headerlink&quot; title=&quot;CONNECT&quot;&gt;&lt;/a&gt;CONNECT&lt;/h4&gt;&lt;p&gt;CONNECT，HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。&lt;/p&gt;
&lt;h4 id=&quot;OPTIONS&quot;&gt;&lt;a href=&quot;#OPTIONS&quot; class=&quot;headerlink&quot; title=&quot;OPTIONS&quot;&gt;&lt;/a&gt;OPTIONS&lt;/h4&gt;&lt;p&gt;OPTIONS，返回 URI 标识资源所支持的所有 HTTP 请求方法。类似 HEAD ，也可以通过发送 OPTIONS 请求判断是否有权限请求该资源。&lt;/p&gt;
&lt;h4 id=&quot;TRACE&quot;&gt;&lt;a href=&quot;#TRACE&quot; class=&quot;headerlink&quot; title=&quot;TRACE&quot;&gt;&lt;/a&gt;TRACE&lt;/h4&gt;&lt;p&gt;TRACE，服务器返回收到的请求信息，该方法主要用户 HTTP 请求的测试和诊断。&lt;/p&gt;
&lt;h4 id=&quot;PATCH&quot;&gt;&lt;a href=&quot;#PATCH&quot; class=&quot;headerlink&quot; title=&quot;PATCH&quot;&gt;&lt;/a&gt;PATCH&lt;/h4&gt;&lt;p&gt;PATCH, 在 2010 年 &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC 5789&lt;/a&gt; 标准中被定义。与 PUT 请求类似，用于资源的更新，但是有两点不同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PATCH 一般用于资源的部分更新，而 PUT 一般用于资源整体的更新；&lt;/li&gt;
&lt;li&gt;当资源不存在时，PATCH 会创建一个新的资源，而 PUT 只会对已有的资源进行更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;&lt;/a&gt;HTTPS&lt;/h2&gt;&lt;p&gt;HTTPS（Hypertext Transfer Protocol Secure）是一种网络安全传输协议。HTTPS 经过 HTTP 进行通信，但是利用 SSL/TLS 来对数据包进行加密，默认端口 443。HTTPS 可以防止攻击者抓包，中间人攻击等（调试 HTTPS 接口时，可以通过给 Charles 配置 HTTPS 私钥来进行抓包）。&lt;/p&gt;
&lt;h4 id=&quot;TLS-SSL&quot;&gt;&lt;a href=&quot;#TLS-SSL&quot; class=&quot;headerlink&quot; title=&quot;TLS/SSL&quot;&gt;&lt;/a&gt;TLS/SSL&lt;/h4&gt;&lt;p&gt;TLS（传输层安全协议，Transport Layer Security）是一种安全协议，前身是 SSL（安全套接层，Secure Sockets Layer）。&lt;/p&gt;
&lt;h4 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h4&gt;&lt;p&gt;详见&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/02/ssl%5C_tls.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SSL/TLS协议运行机制的概述&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;常见复用连接方案&quot;&gt;&lt;a href=&quot;#常见复用连接方案&quot; class=&quot;headerlink&quot; title=&quot;常见复用连接方案&quot;&gt;&lt;/a&gt;常见复用连接方案&lt;/h2&gt;&lt;p&gt;虽然 HTTP/1.x 可以通过设置 Connection:Keep-Alive，但是只能在一段时间里复用该连接，具体时间由服务器控制。这对浏览器端的体验提升比较大，因为请求基本集中在页面刷新那几秒里。但是相对于 App 端，优化的体验并不是很有效果，App 端的请求较为分散，而且时间跨度上一般比较长（服务器端默认连接保持时间 15s 左右）。因此 App 端一般只能从应用层寻找其他解决方案。&lt;/p&gt;
&lt;h4 id=&quot;TCP-长连接&quot;&gt;&lt;a href=&quot;#TCP-长连接&quot; class=&quot;headerlink&quot; title=&quot;TCP 长连接&quot;&gt;&lt;/a&gt;TCP 长连接&lt;/h4&gt;&lt;p&gt;基于 TCP 协议建立长连接通道。但是 TCP 的 Socket 编程技术难度相对复杂很多，而且需要自己制定协议。当然，这样做带来的收益也很明显，信息的传递实时性以及并发请求量对服务器的压力都将得到很好的解决（普通 HTTP 连接在高并发的情况下，频繁创建/销毁连接对资源消耗很大）。&lt;/p&gt;
&lt;h4 id=&quot;HTTP-long-polling&quot;&gt;&lt;a href=&quot;#HTTP-long-polling&quot; class=&quot;headerlink&quot; title=&quot;HTTP long-polling&quot;&gt;&lt;/a&gt;HTTP long-polling&lt;/h4&gt;&lt;p&gt;客户端发送一个 polling 请求到服务器，服务器只有产生新的数据时才会返回数据，不然这个连接会一直保持住。当服务器数据返回后，客户端又将会重新发送一个 polling 请求，如此循环。&lt;br&gt;long-polling 方式每次接收到数据都会重新发起一个相同的请求，因此每次都会带上 Header 以及不能向服务器发送数据，数据通道是单项的，主动权是在服务器。&lt;/p&gt;
&lt;h4 id=&quot;HTTP-streaming&quot;&gt;&lt;a href=&quot;#HTTP-streaming&quot; class=&quot;headerlink&quot; title=&quot;HTTP streaming&quot;&gt;&lt;/a&gt;HTTP streaming&lt;/h4&gt;&lt;p&gt;和 HTTP long-polling 相比，最大的不同在于 streaming 方式在服务端响应了数据之后，并不会断开这个连接，而是持续的通过这个通道传输数据给客户端（显然是单项数据通道，并且不会重复发送 Header 数据）。streaming 利用的就是 HTTP/1.1 的 Transfer Encoding ，通过在 Response  里设置 Transfer Encoding: chunked 告诉客户端后续还有数据，不要中断连接。&lt;/p&gt;
&lt;h4 id=&quot;WebSocket&quot;&gt;&lt;a href=&quot;#WebSocket&quot; class=&quot;headerlink&quot; title=&quot;WebSocket&quot;&gt;&lt;/a&gt;WebSocket&lt;/h4&gt;&lt;p&gt;WebSocket 和 TCP 长连接相似，基于 TCP 协议，有双向的数据通道。WebSocket 的优势在于提供了 Message 的概念，而不是 TCP 长连接的基于字节流。但是 Web Socket 在 2010 年猜才起草，相对来说还比较新，不过新的浏览器都是支持的。Nodejs 中的 &lt;a href=&quot;http://socket.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Socket.IO&lt;/a&gt; 就是基于 WebSocket 实现的，但是同时还支持 Adobe Flash Socket、AJAX 长轮询、AJAX multipart streaming、持久Iframe、JSONP轮询等。Socket.IO 能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;结束语&quot;&gt;&lt;a href=&quot;#结束语&quot; class=&quot;headerlink&quot; title=&quot;结束语&quot;&gt;&lt;/a&gt;结束语&lt;/h2&gt;&lt;p&gt;文中如有错误，望能指出。以上这些基本都是对网络基础的一个回顾和整理，但是在这个过程中也补了很多洞，当然很多内容都没有深入去分析、实战，也有一些必要的知识点没有提及，希望大家能指出。&lt;br&gt;最后的最后，希望大家轻按下方二维码，关注 He 码 🚀🚀 —— 一群年幼无知的码农 boy 的日记 ！&lt;br&gt;&lt;img src=&quot;http://7xtamz.com1.z0.glb.clouddn.com/qrcode_for_gh_ea339e6e1708_430.jpg&quot; alt=&quot;&quot;&gt;     &lt;/p&gt;
&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/246859/http-1-0-vs-1-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mrpeak.cn/blog/http2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTTP 2.0 那点事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;接下来你将会花费 10 分钟左右了解到如下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP 的来世今生&lt;/li&gt;
&lt;li&gt;HTTPS 简介&lt;/li&gt;
&lt;li&gt;HTTP 请求方法介绍&lt;/li&gt;
&lt;li&gt;常见复用连接方案&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;HTTP-的来
    
    </summary>
    
    
      <category term="HTTP" scheme="/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>代码规范那点事</title>
    <link href="/2016/08/13/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <id>/2016/08/13/代码规范那点事/</id>
    <published>2016-08-13T13:05:01.000Z</published>
    <updated>2016-08-13T16:30:41.000Z</updated>
    
    <content type="html">&lt;p&gt;最近这个月，从制作 CocoaPods 私有库，到搭建 Git 服务器，大多数时间都花在了调研和试错上。不过调研试错这个事总是能让你感觉到自己懂的只是皮毛这个事实（所以当你觉得天下无敌的时候那就去调研，TA 会让你爆棚的自信心损失殆尽 💔💔）。以下文字就先记录下关于团队统一代码风格这件事。    &lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;对于团队统一代码风格的好处想必大家都应该清楚，以下我就罗列几点相对比较重要的：     &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;促进团队合作，提高代码的可读性；    &lt;/li&gt;
&lt;li&gt;有助于 Code Review ；    &lt;/li&gt;
&lt;li&gt;甚至可以降低 Bug 出现的概率；    &lt;/li&gt;
&lt;li&gt;自行 YY …..；    &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码规范想必有部分同学会把它和个人习惯混为一谈，其实代码规范和个人习惯压根不是一个层面上的东西。代码规范针对的是团队，而个人习惯仅仅针对你自己。制定代码规范的目的是为了提高团队协作的效率以及代码的可维护性。因此，个人习惯和代码规范擦出火花的时候，很明显你应该遵守规范而不是你自己所谓的那些习惯。当然规范并不是一尘不变的，当产生火花的时候完全可以提议修改代码规范，但是在规范修改之前，你必须要遵守旧的规范。因为团队利益大于一切。     &lt;/p&gt;
&lt;p&gt;举个栗子，&lt;br&gt;A 习惯写 single line 的条件语句。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (a) return;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而 B 自己的习惯是这样，并且 B 还会使用一些格式化代码（Xcode 的 clang-format，js 的 jsFormat 等）的插件来提升开发效率。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (a) {
    return ;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么当 B 去修改 A 的代码时，看着不顺眼，就会把 A 的所有 single line 都消灭掉，因为 B 有插件，秒秒钟解决战斗。这就会导致 A 和 B 冲突的概率大大增加，甚至会造成很多不必要代码合并的成本。想必大家看完这个栗子应该很清楚一个团队制定代码规范的重要性了。 &lt;/p&gt;
&lt;p&gt;一个团队的代码规范首先需要制定一份文档，当出现任何风格冲突的时候，以文档为准。因此团队在开始之初就制定了&lt;a href=&quot;https://github.com/KentonYu/ProgrammingStandard_OC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一份规范&lt;/a&gt;。     &lt;/p&gt;
&lt;p&gt;制定规范文档这是第一步，在这个基础上能不能再提高些效率呢？&lt;br&gt;大多数 iOS 开发者应该都知道 Xcode 的插件 &lt;a href=&quot;https://github.com/travisjeffery/ClangFormat-Xcode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Clang Format&lt;/a&gt;。它是基于 clang-format 命令行工具的一个 Xcode 插件。      &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;clang-format是基于clang的一个命令行工具。这个工具能够自动化格式C/C++/Obj-C代码，支持多种代码风格：Google, Chromium, LLVM, Mozilla, WebKit，也支持自定义风格（通过编写.clang-format文件）。     &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以通过自定义 .clang-format 文件来实现自定义代码风格。这是目前使用的一份&lt;a href=&quot;https://github.com/KentonYu/spacecommander/blob/master/.clang-format&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配置文件&lt;/a&gt;。具体每项参数可以查阅&lt;a href=&quot;http://clang.llvm.org/docs/ClangFormatStyleOptions.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这份文档&lt;/a&gt;。      &lt;/p&gt;
&lt;p&gt;通过这个插件已经可以实现通过快捷键或者在文件保存时格式化代码了，其实做到这一步已经节省了很多开发成本，但是这种方案也是存在一定缺陷。如果通过快捷键去格式化，容易遗漏；保存的时候去格式化，对于像我这样时不时会按 Command + S 的人来说，Xcode 会变得稍显卡顿。那么有没有现成的方案可以进一步优化体验？既然之前的方案有问题，就有必要继续寻找更优解。    &lt;/p&gt;
&lt;p&gt;一轮 Google 之后，&lt;a href=&quot;https://github.com/square/spacecommander&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;spacecommander&lt;/a&gt; 貌似符合大部分需求。它利用 &lt;a href=&quot;https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git Hooks&lt;/a&gt; 可以在 commit 之前验证代码风格符合规范，只有符合规范的代码才允许提交，同时也提供 Shell 脚本来格式化一个文件，或者一整个 Git 仓库。我猜想通过 spacecommander ，可以在不改变自己编码风格（当然只限于格式，具体的命名规范，注释规范还得参照具体规范文档）的前题下，可以实现代码风格统一。因为你开发过程中可以按照个人习惯来，commit 之前使用 spacecommander 提供的脚本对文件进行格式化。这样只需要所有开发人员统一 spacecommander 的 .clangformat 配置文件就可以了。看到这里是不是发现这个轮子是不是刚好命中痛点。那么接下来我就简单描述下使用步骤：      &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;fork &lt;a href=&quot;https://github.com/square/spacecommander&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;spacecommander&lt;/a&gt;；     &lt;/li&gt;
&lt;li&gt;修改其中的 .clangformat 文件以满足自己团队的编码风格，当然有能力也可以修改其中的 Shell 脚本，自定义一些功能；    &lt;/li&gt;
&lt;li&gt;clone 到本地一个较为安全的目录（别一不小心删掉了…）；    &lt;/li&gt;
&lt;li&gt;为了之后方便使用，可以把几个脚本对应设置一个 alias；   &lt;/li&gt;
&lt;li&gt;cd 到项目根目录，执行 clangformatinit ，进行初始化（添加了一个指向本地 spacecommander 仓库的 .clangformat 替身以及在 .git/hooks 中的 pre-commit， hook 相关的可以参见 &lt;a href=&quot;https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pro Git&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;在提交代码之前，spacecommander 都会通过 pre-commit 这个 Hook 来校验修改过的文件，校验通过才允许提交。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如何设置 alias 简化命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 使用zsh 则修改 ~/.zshrc；bash 则修改~/.bash_profile
// 初始化
alias clangformatinit=&amp;quot;/Users/SpaceCommander_iOS/setup-repo.sh&amp;quot;
// 格式化对应文件
alias clangformat=&amp;quot;/Users/SpaceCommander_iOS/format-objc-file.sh&amp;quot;
// 格式化整个仓库
alias clangformatall=&amp;quot;/Users/SpaceCommander_iOS/format-objc-files-in-repo.sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果需要 spacecommander 忽略某个目录下的文件的格式，则可以通过修改 spacecommander/lib/common-lib.sh 脚本来实现。默认它已经忽略了 Pods 和 Carthage 目录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// common-lib.sh 简化版

function objc_files_to_format() {
    optional_base_sha=&amp;quot;$1&amp;quot;
    directories_to_check
    files=$(git diff --cached --name-only $optional_base_sha --diff-filter=ACM -- $locations_to_diff | grep -e &amp;apos;\.m$&amp;apos; -e &amp;apos;\.mm$&amp;apos; -e &amp;apos;\.h$&amp;apos; -e &amp;apos;\.hh$&amp;apos;)
    directories_to_ignore
    echo &amp;quot;$files&amp;quot; | grep -v &amp;apos;Pods/&amp;apos; | grep -v &amp;apos;Carthage/&amp;apos; &amp;gt;&amp;amp;1
}

function all_valid_objc_files_in_repo() {
    directories_to_check
    files=$(git ls-tree --name-only --full-tree -r HEAD -- $locations_to_diff | grep -e &amp;apos;\.m$&amp;apos; -e &amp;apos;\.mm$&amp;apos; -e &amp;apos;\.h$&amp;apos; -e &amp;apos;\.hh$&amp;apos;)
    directories_to_ignore
    echo &amp;quot;$files&amp;quot; | grep -v &amp;apos;Pods/&amp;apos; | grep -v &amp;apos;Carthage/&amp;apos; &amp;gt;&amp;amp;1
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就此初步解决了 iOS 开发的代码风格问题 ———— 一份代码规范以及自定义的 spacecommander。    &lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;这个问题看似有点微不足道，但的确花了毛一天的时间，才找到了较为合适的解决方案。但是在我看来是很值的。不仅能减少后续开发维护过程中由于代码风格引起的麻烦（感谢 spacecommander 这个轮子），而且在调研的过程中，也接触到了一些新的知识，比如 Shell 脚本语言。所以我很喜欢去干这种事情 🙄🙄。 接下来有时间会整理一篇 CocoaPods 私有库相关的博客 ⛳️⛳️。  &lt;/p&gt;
&lt;p&gt;有其它的解决方案，欢迎分享 🖐🖐&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近这个月，从制作 CocoaPods 私有库，到搭建 Git 服务器，大多数时间都花在了调研和试错上。不过调研试错这个事总是能让你感觉到自己懂的只是皮毛这个事实（所以当你觉得天下无敌的时候那就去调研，TA 会让你爆棚的自信心损失殆尽 💔💔）。以下文字就先记录下关于团队
    
    </summary>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods 项目“模块化”实战</title>
    <link href="/2016/07/03/CocoaPods%20%E9%A1%B9%E7%9B%AE%E2%80%9C%E6%A8%A1%E5%9D%97%E5%8C%96%E2%80%9D%E5%AE%9E%E6%88%98/"/>
    <id>/2016/07/03/CocoaPods 项目“模块化”实战/</id>
    <published>2016-07-03T13:05:01.000Z</published>
    <updated>2016-07-03T14:00:31.000Z</updated>
    
    <content type="html">&lt;p&gt;文题套用了现在系统设计中最火的词汇之一 —— 模块化，当然下文中的 “模块化” 只是杀鸡用牛刀了，不过在我的理解里大致意思差不多吧。   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模块化设计是指在对一定范围内的不同功能或相同功能不同性能、不同规格的&lt;a href=&quot;http://wiki.mbalib.com/wiki/%E4%BA%A7%E5%93%81&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;产品&lt;/a&gt;进行功能分析的基础上，划分并设计出一系列功能模块，通过模块的选择和组合可以构成不同的产品，以满足&lt;a href=&quot;http://wiki.mbalib.com/wiki/%E5%B8%82%E5%9C%BA&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;市场&lt;/a&gt;的不同&lt;a href=&quot;http://wiki.mbalib.com/wiki/%E9%9C%80%E6%B1%82&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;需求&lt;/a&gt;的设计方法。   —— WIKI&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/247ec798cce1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;完整文章的传送门&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;文题套用了现在系统设计中最火的词汇之一 —— 模块化，当然下文中的 “模块化” 只是杀鸡用牛刀了，不过在我的理解里大致意思差不多吧。   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模块化设计是指在对一定范围内的不同功能或相同功能不同性能、不同规格的&lt;a href=&quot;http
    
    </summary>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC 的 load 和 initialize</title>
    <link href="/2016/06/16/OC%20%E7%9A%84%20load%20%E5%92%8C%20initialize/"/>
    <id>/2016/06/16/OC 的 load 和 initialize/</id>
    <published>2016-06-16T08:05:01.000Z</published>
    <updated>2016-06-16T08:09:55.000Z</updated>
    
    <content type="html">&lt;p&gt;其实有时间还是需要多补充下基础知识的，毕竟步子跨太大会扯到裆。&lt;/p&gt;
&lt;h1 id=&quot;load&quot;&gt;&lt;a href=&quot;#load&quot; class=&quot;headerlink&quot; title=&quot;- load&quot;&gt;&lt;/a&gt;- load&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是 Apple Doc 上对 - load 的描述。（强行秀一波翻译，其实我是个英语渣，最好还是看英文吧）当一个类或分类被添加到运行时的时候会触发这个方法；实现这个方法可以在加载这个类时执行一些特定的操作。&lt;/p&gt;
&lt;p&gt;写下 demo 看看这个方法在继承树上是什么执行顺序，虽然文档里有写。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A class’s +load method is called after all of its superclasses’ +load methods. &lt;/li&gt;
&lt;li&gt;A category +load method is called after the class’s own +load method.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;先执行所有的父类的 - load 方法，分类的 - load 方法将会是最后执行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// Parent.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (void)load &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Parent load&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Child.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (void)load &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Child load&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Child+Category.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (void)load &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Child Category load&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtamz.com1.z0.glb.clouddn.com/20160616-1.png&quot; alt=&quot;load&quot;&gt;&lt;/p&gt;
&lt;p&gt;有兴趣的朋友可以自己去试试。&lt;/p&gt;
&lt;h1 id=&quot;initialize&quot;&gt;&lt;a href=&quot;#initialize&quot; class=&quot;headerlink&quot; title=&quot;- initialize&quot;&gt;&lt;/a&gt;- initialize&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Initializes the class before it receives its first message.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在收到第一条消息之前初始化类，也就是说你 #import 了这个类，但是没有用到这个类，就不会初始化它（有点懒加载的味道）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses. The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize].&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;runtime 会线程安全地发送  initialize 消息给类。父类会比它的子类先收到这个消息。如果子类没有实现 initialize 这个方法，那么父类的 initialize 方法会被执行多次 —— 否则 runtime 将会调用子类实现 —— 除非子类明确调用 [super initialize] 。&lt;/p&gt;
&lt;p&gt;demo time。动手 ba 一 ba 。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// Parent.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (void)initialize &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Parent initialize&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Child.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (void)initialize &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Child initialize&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Child+Category.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (void)initialize &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Child Category initialize&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// main.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, const char * argv[]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @autoreleasepool &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [Child new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [Child new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtamz.com1.z0.glb.clouddn.com/20160616-2.png&quot; alt=&quot;initialize&quot;&gt;&lt;/p&gt;
&lt;p&gt;结果中可以看出分类中的 initialize 会覆盖掉类中 initialize 方法，而父类的 initialize 方法仍旧会被执行。&lt;br&gt;接下来我们把子类中的 initialize 方法注释掉，重新跑一遍看看结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtamz.com1.z0.glb.clouddn.com/20160616-3.png&quot; alt=&quot;initialize&quot;&gt;&lt;/p&gt;
&lt;p&gt;发现父类的 initialize 方法被调用了两遍，然后我们看文档中的这段话。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这段话的大致意思就是说 runtime 会发送 initialize 给这个类以及这个类的所有父类，因此当我们使用 Child 的时候，runtime 会先发送 initialize 消息给 Parent ，然后发送给 Child ，但是 Child 没有实现 initialize 方法，所以就再次执行了 Parent 的 initialize 。&lt;br&gt;所以如果使用一个 Grandson （没有实现 initialize），则 Parent 的 initialize 将会被调用三次。&lt;/p&gt;
&lt;p&gt;有时候我们可能需要这样的效果，但是大多数时间我们是不需要这样的，因此我们可以在实现 initialize 时，这样写来避免这个问题。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (void)initialize &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self == [ClassName self]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         // ... do the initialization ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;用处（欢迎补充）&quot;&gt;&lt;a href=&quot;#用处（欢迎补充）&quot; class=&quot;headerlink&quot; title=&quot;用处（欢迎补充）&quot;&gt;&lt;/a&gt;用处（欢迎补充）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;load&lt;br&gt;在 load 中实现Method Swizzling：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (void)load &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Method a = class_getInstanceMethod([self class], @selector(logA));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Method b = class_getInstanceMethod([self class], @selector(logB));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    method_exchangeImplementations(a, b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)logA &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;A&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)logB &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;B&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;initialize&lt;br&gt;初始化一些静态对象&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// static NSArray *array = @[@1, @2]; //这样是不行滴，编译器不接受，只有数据类型才能这样哦&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static NSArray *array;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (void)initialize &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self == [Parent class]) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        array = @[@1, @2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;load&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;initialize&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;调用时机&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;类被添加到 runtime 时&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;类第一次接收到消息之前&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;调用顺序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;父类-&amp;gt;子类-&amp;gt;分类&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;父类 -&amp;gt; 子类（分类）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;调用次数&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1次&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;多次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;显式调用父类&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;否&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分类中的实现&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;类和分类都执行&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;覆盖类的实现，执行分类的实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;线程安全&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;安全&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;安全&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上表主要就是这两个方法的特点，因为是线程安全的，所以在这两个方法尽量少执行复杂的操作，防止阻塞线程。&lt;/p&gt;
&lt;p&gt;以上就是我对这两个方法的描述，如有不对望指正，给个喜欢以示支持。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;其实有时间还是需要多补充下基础知识的，毕竟步子跨太大会扯到裆。&lt;/p&gt;
&lt;h1 id=&quot;load&quot;&gt;&lt;a href=&quot;#load&quot; class=&quot;headerlink&quot; title=&quot;- load&quot;&gt;&lt;/a&gt;- load&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Invoke
    
    </summary>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="Objective-C" scheme="/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 上搭建 Shadowsocks</title>
    <link href="/2016/06/02/Ubuntu%20%E4%B8%8A%E6%90%AD%E5%BB%BA%20Shadowsocks/"/>
    <id>/2016/06/02/Ubuntu 上搭建 Shadowsocks/</id>
    <published>2016-06-02T02:10:01.000Z</published>
    <updated>2016-06-02T04:13:35.000Z</updated>
    
    <content type="html">&lt;p&gt;其实以前一直用 Centos 上搭的。有苦难言，之前想 10G disk 闲着，想搞个 gitlab 上去，然后在那上面一通搞，最后以为系统版本原因吧，就换成了 Ubuntu，虽然成功了，但是 502 ，&lt;a href=&quot;http://stackoverflow.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt; said: gitlab 至少 1G 的内存。我的 VPS 512M ……典型的偷鸡不成蚀把米～&lt;/p&gt;
&lt;p&gt;那原来的 SS 没了，得先把它搭起来，毕竟还是得靠它过日子的……&lt;br&gt;记得当时 Centos 上花了很久才搭好的，Ubuntu 上秒秒钟啊，奇怪。&lt;/p&gt;
&lt;h3 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一台 VPS （Ubuntu）（我是在&lt;a href=&quot;http://banwagong.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;搬瓦工&lt;/a&gt;上买的，蛮实惠）&lt;/li&gt;
&lt;li&gt;基本的 linux 操作，vi 的操作（别担心，就用到没几个。。。）  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h3&gt;&lt;p&gt;1.先 ssh 到 VPS&lt;/p&gt;
&lt;pre&gt;
ssh -p 端口号 root@ip
sudo passwd root   //第一次上去可以把 root 密码改了，搬瓦工初始密码随机的，并记不住
&lt;/pre&gt;

&lt;p&gt;2.更新下 apt ，安装 pip, ss&lt;/p&gt;
&lt;pre&gt;
apt-get update
apt-get install python-pip
pip install shadowsocks
&lt;/pre&gt;

&lt;p&gt;3.建一个 ss 配置文件&lt;/p&gt;
&lt;pre&gt;
vi shadowsocks.json
//把下面这个 json 拷进去， 按 command + v 之前，先按 i 进入insert 模式
{
&quot;server&quot;:&quot;your ip&quot;,
&quot;server_port&quot;:50003,
&quot;local_port&quot;:1080,
&quot;password&quot;:&quot;123456&quot;,
&quot;timeout&quot;:600,
&quot;method&quot;:&quot;aes-256-cfb&quot;
}
&lt;/pre&gt;

&lt;p&gt;4.Start&lt;/p&gt;
&lt;pre&gt;
ssserver -c shadowsocks.json -d start
&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;其实以前一直用 Centos 上搭的。有苦难言，之前想 10G disk 闲着，想搞个 gitlab 上去，然后在那上面一通搞，最后以为系统版本原因吧，就换成了 Ubuntu，虽然成功了，但是 502 ，&lt;a href=&quot;http://stackoverflow.com/&quot;
    
    </summary>
    
    
      <category term="日常" scheme="/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>CAShapeLayer 的简单介绍</title>
    <link href="/2016/05/16/CAShapeLayer%20%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>/2016/05/16/CAShapeLayer 的简单介绍/</id>
    <published>2016-05-16T14:51:01.000Z</published>
    <updated>2016-05-17T05:10:43.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;CAShapeLayer&quot;&gt;&lt;a href=&quot;#CAShapeLayer&quot; class=&quot;headerlink&quot; title=&quot;CAShapeLayer&quot;&gt;&lt;/a&gt;CAShapeLayer&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;CAShapeLayer 是一个通过矢量图形而不是 bitmap 来绘制的图层子类。可以指定颜色、线宽等属性，用CGPath 来定义想要绘制的图形，最后 CAShapeLayer 就会自动渲染出来了。当然，你也可以用 Core Graphics 直接向原始的 CALyer 的内容中绘制一个路径（&lt;code&gt;- drawLayer: inContext:&lt;/code&gt;），相比之下，使用 CAShapeLayer 有以下一些优点：    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;渲染快速。CAShapeLayer 使用了硬件加速，绘制同一图形会比用 Core Graphics 快很多。&lt;/li&gt;
&lt;li&gt;高效使用内存。一个 CAShapeLayer 不需要像普通 CALayer 一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。&lt;/li&gt;
&lt;li&gt;不会被图层边界剪裁掉。一个 CAShapeLayer 可以在边界之外绘制。你的图层路径不会像在使用 Core Graphics 的普通 CALayer 一样被剪裁掉.&lt;/li&gt;
&lt;li&gt;不会出现像素化。当你给 CAShapeLayer 做 3D 变换时，它不像一个有寄宿图的普通图层一样变得像素化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;主要属性&quot;&gt;&lt;a href=&quot;#主要属性&quot; class=&quot;headerlink&quot; title=&quot;主要属性&quot;&gt;&lt;/a&gt;主要属性&lt;/h4&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;
// CAShapeLayer 绘制的路径
@property(nullable) CGPathRef path;

//路径中的填充颜色
@property(nullable) CGColorRef fillColor;

//填充规则
@property(copy) NSString *fillRule;

//画笔颜色（路径的颜色，边框颜色）
@property(nullable) CGColorRef strokeColor;

//这是一组范围值，路径绘制开始和结束的范围（0 -&gt; 1）
@property CGFloat strokeStart;
@property CGFloat strokeEnd;

//设置虚线显示的起点距离，设置为8，则显示长度8之后的线
@property CGFloat lineDashPhase;
//设置虚线线段的长度和空格的长度，@[@20,@30,@40,@50],画20空30画40空50
@property(nullable, copy) NSArray&lt;nsnumber *=&quot;&quot;&gt; *lineDashPattern;

//以下属性参见 UIBezierPath 的介绍
@property CGFloat lineWidth;
@property CGFloat miterLimit;
@property(copy) NSString *lineCap;
@property(copy) NSString *lineJoin;

&lt;/nsnumber&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;Show-You-Code&quot;&gt;&lt;a href=&quot;#Show-You-Code&quot; class=&quot;headerlink&quot; title=&quot;Show You Code&quot;&gt;&lt;/a&gt;Show You Code&lt;/h4&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;先上本 Demo 截图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtamz.com1.z0.glb.clouddn.com/CAShapeLayerDemo.png&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;p&gt;1.使用 CAShapeLayer 绘制一个圆角矩形：&lt;/p&gt;
&lt;pre&gt;

#pragma mark Getter

- (UIBezierPath *)path {
    if (!_path) {
        _path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, 100.f, CGRectGetWidth([UIScreen mainScreen].bounds), 44.f) cornerRadius:22.f];
    }
    return _path;
}

- (CAShapeLayer *)shapeLayer {
    if (!_shapeLayer) {
        _shapeLayer = ({
            CAShapeLayer *layer = [[CAShapeLayer alloc] init];
            layer.path        = self.path.CGPath;
            layer.lineWidth   = 2.f;
            layer.strokeColor = [UIColor greenColor].CGColor;
            layer.fillColor   = [UIColor redColor].CGColor;
            // strokeStart 绘制起点 strokeEnd 绘制终点  取值是 0-1
            layer.strokeStart = 0;
            layer.strokeEnd   = 0.7f;
            layer;
        });
    }
    return _shapeLayer;
}
&lt;/pre&gt;

&lt;p&gt;2.绘制一根不同间隔，不同长度的虚线&lt;/p&gt;
&lt;pre&gt;

#pragma mark Getter

- (UIBezierPath *)dashLinePath {
    if (!_dashLinePath) {
        _dashLinePath = ({
            UIBezierPath *path = [UIBezierPath bezierPath];
            [path moveToPoint:CGPointMake(20.f, 180.f)];
            [path addLineToPoint:CGPointMake(CGRectGetWidth(self.frame) - 20.f, 180.f)];
            path;
        });
    }
    return _dashLinePath;
}

- (CAShapeLayer *)dashLineShapeLayer {
    if (!_dashLineShapeLayer) {
        _dashLineShapeLayer = ({
            CAShapeLayer *layer = [[CAShapeLayer alloc] init];
            layer.path = self.dashLinePath.CGPath;
            layer.lineDashPhase   = 8;
            layer.lineDashPattern = @[@10, @20, @30, @60];
            layer.strokeColor = [UIColor greenColor].CGColor;
            layer.lineWidth   = 2.f;
            layer;
        });
    }
    return _dashLineShapeLayer;
}
&lt;/pre&gt;   

&lt;p&gt;lineDashPhase：绘制的虚线显示在屏幕上的起点，比如设置为10，则从整条线的 10 的位置开始才显示。&lt;br&gt;lineDashPattern：绘制虚线的格式，@[@10, @20, @30, @60],画10个点的线空20个点，以此类推。如果只设置一个元素，则线和间隔宽度相等。&lt;/p&gt;
&lt;p&gt;3.使用 fillRule 属性，实现两个区域的取非&lt;/p&gt;
&lt;pre&gt;

# pragma mark Getter

- (UIBezierPath *)fillRulePath {
    if (!_fillRulePath) {
        //这里先绘制哪个 Path 效果一样
        _fillRulePath = [UIBezierPath bezierPathWithRect:CGRectMake(20.f, 200.f, CGRectGetWidth(self.frame)-40.f, 200.f)];
        [_fillRulePath appendPath:[UIBezierPath bezierPathWithArcCenter:CGPointMake(CGRectGetWidth(self.frame)/2.f, 300.f) radius:50.f startAngle:0 endAngle:2*M_PI clockwise:NO]];
    }
    return _fillRulePath;
}

- (CAShapeLayer *)fillRuleShapeLayer {
    if (!_fillRuleShapeLayer) {
        _fillRuleShapeLayer = ({
            CAShapeLayer *layer = [[CAShapeLayer alloc] init];
            layer.path = self.fillRulePath.CGPath;
            layer.fillRule = kCAFillRuleEvenOdd;
            layer.fillColor = [UIColor yellowColor].CGColor;
            layer;
        });
    }
    return _fillRuleShapeLayer;
}

&lt;/pre&gt;

&lt;p&gt;填充规则介绍：&lt;/p&gt;
&lt;p&gt;kCAFillRuleNonZero：默认值，非零规则，当这个点作任意方法的射线，然后看射线和路径的交点方向，选择一个作为基准方向，如果方向一致则加1，方向不一致则减1。为0时，点不在路径内。      &lt;/p&gt;
&lt;p&gt;kCAFillRuleEvenOdd：奇偶规则，当这个点作任意方法的射线，射线和路径的交点数量是奇数则认为点在内部。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://7xtamz.com1.z0.glb.clouddn.com/CAShapeLayerDemo-1.png&quot; alt=&quot;fillRule&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图（不知道找什么画图软件好，就用了 Sketch ），如果使用 kCAFillRuleNonZero 规则，则该射线和两条路径相交，并且交点方向都是逆时针，所以点在路径内。&lt;br&gt;如果使用 kCAFillRuleEvenOdd 规则，则该射线与路径有两个交点，为偶数，所以该点不在范围内。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;CAShapeLayer 基本属性不多，主要还是需要通过不断的实践，结合贝塞尔曲线来实现不同的需求。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码及相关资料&quot;&gt;&lt;a href=&quot;#代码及相关资料&quot; class=&quot;headerlink&quot; title=&quot;代码及相关资料&quot;&gt;&lt;/a&gt;代码及相关资料&lt;/h4&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/KentonYu/SubLayersDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bihongbo.com/2016/01/03/memoryGhostdrawRect/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用 CAShapeLayer 优化 drawRect 的一个例子&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CAShapeLayer&quot;&gt;&lt;a href=&quot;#CAShapeLayer&quot; class=&quot;headerlink&quot; title=&quot;CAShapeLayer&quot;&gt;&lt;/a&gt;CAShapeLayer&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;CAShapeLayer 是一个通过矢量图形
    
    </summary>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="CALayer" scheme="/tags/CALayer/"/>
    
  </entry>
  
  <entry>
    <title>记一次奇怪的面试经历</title>
    <link href="/2016/05/06/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A5%87%E6%80%AA%E7%9A%84%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    <id>/2016/05/06/记一次奇怪的面试经历/</id>
    <published>2016-05-06T15:14:01.000Z</published>
    <updated>2016-05-06T15:19:20.000Z</updated>
    
    <content type="html">&lt;p&gt;周三接到一个HR的电话说他们招 iOS 开发实习生。古人云：参加面试，不论成败，重要的是可以发现自己平时学习的不足，我也就抱着试试的心态去面试了。&lt;a href=&quot;http://www.kujiale.com/about&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;群核云计算(酷家乐)&lt;/a&gt;一个B轮的云计算家装企业。&lt;br&gt;两点半到的那里，简单的参观了下之后，就等面试官来了。结果是一个 Java 工程师来面试（上机测试）。带到了零食储物间，给了我一张A4纸。一道编程题，然后就留我一个人敲。接下来我就讲讲这次奇怪面试唯一的一道题吧。。真的没其他问题了。当然问了我的姓名，实习时间…&lt;br&gt;这道题总得来说就是把 WB 的上网记录同步到公安局（模拟一下，同一个机子的文件拷贝）。下面直接贴图吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtamz.com2.z0.glb.clouddn.com/IMG_9608.JPG&quot; alt=&quot;唯一的题目&quot;&gt;&lt;/p&gt;
&lt;p&gt;怎么越看越不像是在考客户端开发的。反正不管了。我就撸了起来。45分钟之后，发现 for for 嵌套 for ，字符串分割，拼接… 自己都看不下去了。就主动去找面试官。。。感觉自己完全能力不够啊。。。结果面试官跟我说就这样写，能跑就行。然并软，为什么不操作数据库，而是这个一坨坨的字符串。我当时心里一群草泥马奔过。。平时客户端开发的确没遇到过这样的需求，自己写的已经很凌乱了，决定重新换个思路。然后我就用了 SQLite …  整个题目感觉有点像增量备份（Incremental Backup）…  &lt;/p&gt;
&lt;p&gt;不知道有没有大神能给我讲个其他思路…我真觉得 for for 的大量操作 string 很奇怪…&lt;/p&gt;
&lt;p&gt;最后五点了，想想主要部分差不多了，就算了。就找了面试官，心想还会有接下来的面试。  &lt;/p&gt;
&lt;p&gt;情理之中，意料之外。让我跑了几遍，测了下大致的结果。瞄了下代码，然后说“时间也差不多了，今天就到这里”。还真没想到结局竟然是这样，看来这次面试是 GG 了。估计我做的时间太长了吧…&lt;/p&gt;
&lt;p&gt;全当日记，记录一下。  &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;周三接到一个HR的电话说他们招 iOS 开发实习生。古人云：参加面试，不论成败，重要的是可以发现自己平时学习的不足，我也就抱着试试的心态去面试了。&lt;a href=&quot;http://www.kujiale.com/about&quot; target=&quot;_blank&quot; rel=&quot;exte
    
    </summary>
    
    
      <category term="码字" scheme="/tags/%E7%A0%81%E5%AD%97/"/>
    
      <category term="面试" scheme="/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何Copy框架：自定义Xcode Template</title>
    <link href="/2016/04/27/%E5%A6%82%E4%BD%95Copy%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89Xcode%20Template/"/>
    <id>/2016/04/27/如何Copy框架：自定义Xcode Template/</id>
    <published>2016-04-27T04:22:07.000Z</published>
    <updated>2016-05-02T03:21:34.000Z</updated>
    
    <content type="html">&lt;p&gt;每次开始一个新项目，大家都是怎么搭项目框架的？我只知道下面这两种方法，欢迎大家补充～&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过从Git/SVN上pull公司的项目框架，修改相关配置文件。&lt;/li&gt;
&lt;li&gt;command+c 、 command+v ？？&lt;/li&gt;
&lt;li&gt;所有的公有组件都做成私有pods库？好像也可以凸^-^凸&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first one感觉效率已经很高了吧。我只要&lt;code&gt;git clone&lt;/code&gt;,修改下工程名，搞定。但是我们回头想想，假如我们约定的是每个项目内的文件都统一前缀。GG。所有class手动rename。。。。。。。&lt;br&gt;好，终于rename完成了。咦，那个文件头部版权信息怎么办，跟我的工程名不一样呀，哎呀，有一些连公司名都不一样，这样的code怎么show出去。感觉就给人一种代码搬运工的feel～～（当然第三方的当然不能去改人家的版权信息昂）&lt;br&gt;second one 同上，更累点&lt;br&gt;The third one，倒也可以吧，实际没有操作过，但是版权信息的问题还是变不了滴～～而且自己所有可复用的组件都打成Pods库，想想也不简单吧。&lt;/p&gt;
&lt;p&gt;好吧，我说完了，个人见解QAQ，回到主题——通过Xcode 的Project Template 创建项目。&lt;/p&gt;
&lt;p&gt;大家可以到这个目录底下（&lt;code&gt;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/Project Templates/iOS/Application/Single View Application.xctemplate/TemplateInfo.plist&lt;/code&gt;），看下&lt;code&gt;TemplateInfo.plist&lt;/code&gt;这个plist文件。这个文件就是Project Template的配置文件。我们先来了解下这个plist中的主要的几个key。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kind：required key。这个key的value不会从父模板继承下来，所以自己定义的一个新模板，必须设置Kind，当设置错误或者不设置将会导致你不能在创建工程的时候看到你的模板或者创建的时候Xcode crash，Kind有以下几种类型：&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Xcode.Xcode3.ProjectTemplateUnitKind&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;指定该模板是工程模板&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Xcode.IDEFoundation.TextSubstitutionFileTemplateKind&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;指定该模板是文件模板&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;more&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;more&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Identifier：required key。唯一标识。不能重复。For example: com.yourcompany.yourtemplate.templatename。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ancestors：该模板的父类。可以自己选择继承一个或多个。具体可以看Xcode自带模板Identifier。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Concrete：该Key设置为YES的模板才可以显示在new project的dialog中，此时这个模板不能被其他模板继承。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Definitions 和 Nodes：这两个Key具体描述不清楚，Nodes里定义的是工程中的文件目录结构，Definitions中的Path定义的是该模板文件的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SortOrder：在dialog中的位置，越大越前面&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实了解这些Key差不多就可以自定义 Template Project啦。。。。大家可以动手来have a try 。&lt;/p&gt;
&lt;p&gt;如果需要更多相关内容，自行Google。&lt;/p&gt;
&lt;p&gt;附上一个&lt;a href=&quot;http://7xtamz.com2.z0.glb.clouddn.com/plistRelease.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自制小工具&lt;/a&gt;。&lt;br&gt;可以把你制作的模板文件导成模板plist，移入Xcode目录中就可以用了。&lt;/p&gt;
&lt;p&gt;考虑貌似用的storyboard也不多，干脆就不继承storyboard模板了，有需要的可以自己在数据源文件夹自己加Main. storyboard,然后在build setting设置interface 为Main。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;1.目前文件夹中没生成Main.storyboard。工程创建之后需要手动复制一个Main.storyboard到生成的&lt;code&gt;KentonYuApplication.xctemplate&lt;/code&gt;文件夹里。&lt;br&gt;2.或者手动从工程的project.pbxproj中移除storyboard相关的引用。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;里面也可以用Podfile,只需要把你的Podfile文件放在数据源第一级目录里，然后创建的工程执行&lt;code&gt;pod install&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;欢淫评论bugs～～。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;每次开始一个新项目，大家都是怎么搭项目框架的？我只知道下面这两种方法，欢迎大家补充～&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过从Git/SVN上pull公司的项目框架，修改相关配置文件。&lt;/li&gt;
&lt;li&gt;command+c 、 command+v ？？&lt;/li&gt;
&lt;li&gt;所有的公有
    
    </summary>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="Xcode" scheme="/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 读书笔记</title>
    <link href="/2016/03/27/Effective%20Objective-C%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>/2016/03/27/Effective Objective-C 读书笔记/</id>
    <published>2016-03-27T02:22:07.000Z</published>
    <updated>2016-05-02T02:44:14.000Z</updated>
    
    <content type="html">&lt;p&gt;时间什么的，挤挤就有了。Effective这本书在iOS编程领域知名度还是蛮高的＝_＝。这篇文章就来记录一些读书笔记吧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;关于常量的命名法：常量局限于某“编译单元”（也就是在实现文件.m之内），则前面加字母k；若常量在类之外可见，则通常已类名做为前缀。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;//file .m&lt;br&gt;static const NSTimeInterval kAnimationDuration = 0.3;&lt;br&gt;&lt;/code&gt;&lt;br&gt;假如上面的变量不声明static，则编译器会为它创建一个“外部符号”（external symbol）。此时在另外文件申明了同名的变量，编译器就会报错。&lt;br&gt;&lt;code&gt;&lt;br&gt;duplicate symbol _kAnimationDuration in:……&lt;br&gt;&lt;/code&gt;&lt;br&gt;事实上，一个静态（static）不可变（const）变量，编译器不会创建符号，会像define一样进行替换，但是它有类型信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;垃圾收集器（GC），iOS系统中没有GC，MAC OS X 10.8之前有GC，但是之后也正式废弃了，所以目前OC中不存在GC。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果有非Objective-C的对象，比如CoreFoundation中的对象或由malloc()分配在堆中的内存，那么需要在dealloc中清理。dealloc中还需要取消原来订阅的“KVO”或NSNotificationCenter等通知。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)dealloc &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   CFRelease(_coreFoundationObject);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   free(_heapAllocatedMemoryBlob);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [[NSNotificationCenter defaultCenter] removeObserver:self];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // [super dealloc];  //ARC中不需要调用super&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过自动释放池块来降低内存峰值。是否应该用池来优化效率，完全取决于具体的应用程序。首先应该监控内存用量，如果有必要优化，再通过池来优化。尽管自动释放池的开销不太大，但毕竟是有的。所以不要简历额外的自动释放池。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for(int i=0; i&amp;lt;100000; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @autoreleasepool &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         [self doSomethingWithInt:i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;向已回收的对象发送消息是不安全的。这么做有时可以，有时不行。具体可行与否，完全取决于对象所占的内存有没有被其他内存内容所重写。而这块内存有没有被移作它用又不确定，因此程序会偶尔奔溃。&lt;br&gt;在没有奔溃的情况下有两种可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那块内存只被复用了其中一部分，所以对象中有效的某些二进制数据依旧有效。&lt;/li&gt;
&lt;li&gt;那块内存对象恰好为另外一个有效且存活的对象所占据。&lt;br&gt;这样的问题可以通过用“僵尸对象”调试，开启方法：编辑应用的scheme，在对话框的左侧选择Run，切换到Diagnostics分页，勾选Enable Zombie Objects。&lt;br&gt;当然这种情况普遍存在于MRC时期，在ARC时期需要通过比较复杂的代码才能把僵尸对象表现出来。我的理解就是MRC中的野指针。因此在MRC中release对象后，最好将指针置空来避免这个问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于实例变量和属性的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在对象内部读取数据时，应该直接通过实例变量来读取，而进行赋值时，则应该通过属性来写。&lt;/li&gt;
&lt;li&gt;在初始化方法或dealloc中，应该用实例变量。&lt;/li&gt;
&lt;li&gt;用懒加载来配置某份数据时，应该用属性来读取。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;objc_msgSend的作用&lt;br&gt; C语言使用“静态绑定”，编译器就能决定运行时所应调用的函数。&lt;br&gt; OC使用的是“动态绑定”，所有调用的函数直到运行期才能确定。&lt;br&gt; OC中给某个对象发送消息，发生的步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用objc_msgSend(id self, SEL cmd, …)&lt;/li&gt;
&lt;li&gt;该函数从接收对象所属的类中搜寻它的”方法列表”，如果能找到则会跳到相应的实现代码，否则沿着继承体系继续往上查找，找到之后进行跳转。&lt;/li&gt;
&lt;li&gt;如果最终没找到，则会执行“消息转发”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过以上几步才能完成一次消息的发送，因此objc_msgSend()有一张“快速映射表”来缓存已经匹配的结果，所以给对象发送相同的消息，那么执行起来就很快了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息转发(message forwarding)机制&lt;br&gt; 消息转发分两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先征询接收者所属的类，看其是否能动态添加方法，以处理当前这个“未知的选择子”，这叫做“动态方法解析”。&lt;/li&gt;
&lt;li&gt;如果第一阶段结束，那么接收者就无法再以动态新增方法的手段来响应该消息了。此时，运行期系统会请求接收者看看有没有其他对象能处理该消息。若有，则运行期系统会把消息转发给那个对象。然后消息转发过程结束。若没有“备援的接收者”，运行期系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接收者最后一次机会来处理这条消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态方法解析：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//实例方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; + (BOOL)resolveInstanceMethod:(SEL)selector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//类方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; + (BOOL)resolveClassMethod:(SEL)selector&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 备援接收者：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//有备援对象则返回，无则返回nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)forwardingTargetForSelector:(SEL)selector&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 完整的消息转发：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; //可以改变消息内容，比如追加一个参数，或更换选择子等等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - (id)forwardInvocation:(NSInvocation *)invocation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//动态添加方法(第三个参数为函数指针，指向待添加的函数，第四个参数为添加方法的类型编码，第一个表示方法的返回值类型，后面表示方法的参数类型)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_addMethod(Class, selector, IMP, typeEncoding);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1155692-38a34cc2739f4452.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;类型编码表&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方法调配(method swizzling)&lt;br&gt;Method Swizzling：在运行期改变给定的选择子名称对应的方法。&lt;br&gt;获得方法的实现&lt;br&gt;&lt;code&gt;&lt;br&gt;Method class_getInstanceMethod(Class aClass, SEL aSelector)&lt;br&gt;&lt;/code&gt;&lt;br&gt;交换两个方法的函数&lt;br&gt;&lt;code&gt;&lt;br&gt;void method_exchangeImplementations(Method m1, Method m2)&lt;br&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这两个方法可以为“完全不知道其具体实现的”黑盒方法增加日志记录功能，非常有助于调试。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;时间什么的，挤挤就有了。Effective这本书在iOS编程领域知名度还是蛮高的＝_＝。这篇文章就来记录一些读书笔记吧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;关于常量的命名法：常量局限于某“编译单元”（也就是在实现文件.m之内），则前面加字母k；若常量在类之外可见，则通常已类名
    
    </summary>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="Objective-C" scheme="/tags/Objective-C/"/>
    
      <category term="读书笔记" scheme="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>对 Git Flow 开发模型的理解</title>
    <link href="/2016/03/05/git-Flow-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>/2016/03/05/git-Flow-开发模型/</id>
    <published>2016-03-05T00:57:07.000Z</published>
    <updated>2016-05-02T02:34:32.000Z</updated>
    
    <content type="html">&lt;p&gt;又是一段时间没写博客了。。一直生活在甲方的世界里。。。可能也是自己懒癌复发了吧。。&lt;br&gt;ps:图片无法显示请点击：&lt;a href=&quot;http://www.jianshu.com/p/c9d7e16744e0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;“传送门”&lt;/a&gt;&lt;br&gt;最近一个项目，因为需求上比较容易（开发时间比较充裕），所以尝试了通过Git Flow来管理项目源代码，从而探索下是否可以提高整体开发效率。在这之前，公司用的只是dev + master，几个开发同时在dev上开发，时不时就会有冲突，特别是项目中的xib文件较多时，很容易发生xib冲突（头疼。。。当然只要在commit之前看下文件变更记录，把不需要的变更放弃掉，但是难免会有疏忽的时候）。&lt;/p&gt;
&lt;h1 id=&quot;Git-Flow-介绍&quot;&gt;&lt;a href=&quot;#Git-Flow-介绍&quot; class=&quot;headerlink&quot; title=&quot;Git Flow 介绍&quot;&gt;&lt;/a&gt;Git Flow 介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Git Flow是构建在Git之上的一个组织软件开发活动的模型，是在Git之上构建的一项软件开发最佳实践。Git Flow是一套使用Git进行源代码管理时的一套行为规范和简化部分Git操作的工具。&lt;br&gt;&lt;img src=&quot;http://7xno6f.com1.z0.glb.clouddn.com/blog-GitFlow01YiLAQQnlPV.jpg&quot; alt=&quot;Git Flow 全貌&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实学习Git Flow，主要还是理解几个分支的用处，在使用时通过严格的分割，将冲突概率降到最低，提高开发效率。下面我就按自己的理解来描述下主要的几种分支。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;master&lt;br&gt;这个分支上只存在上线版本，每个commit都应该对应一个版本号。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;仅在发布新的可供部署的代码时才更新master分支上的代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;develop&lt;br&gt;dev分支简单来说就是开发分支，它保存着开发过程中的最新版本。也就是说每当完成一个需求（feature）就应该合并到dev分支上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;feature&lt;br&gt;feature：功能。这个分支显而易见，是用来存每一个新功能（需求）的。每一个功能模块（较复杂的最好拆分下）可以做为一个feature。一般情况，每一轮迭代结束后的feature分支都应被合到dev分支上。这类分支也可以是做为实验性分支，比如在上面尝试一些开发，如果达不到预期效果也可以放弃该分支。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;release&lt;br&gt;release分支可以看做是存储上线版本之前的分支。用一个实际情况来描述下，第二轮sprint结束，需要上线一个版本（还未进行测试和fix bugs），这时候第三轮sprint又要开始了。根据之前master的原则，是只存在上线版本的，因此我们可以用release分支，存一个待上线版本，然后dev就可以进行sprint3迭代了。这时候sprint2的bug 就可以在release上修复，当测试通过之后，就可以将release合进master上，同时dev需要merge下release分支。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hotfix&lt;br&gt;hotfix：热补丁。它的作用是线上版本出现bug时，可以通过hotfix来fix，然后产生一个新的发布版本，合并到master上，同时dev需要merge hotfix。这样的好处是可以打断dev上正在开发的进度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上就是Git Flow模型的大致概念。在实际开发过程中，这个模型并不是一成不变的，根据每个开发团队或每个项目可以进行一定的变化。&lt;/p&gt;
&lt;h1 id=&quot;Git-Flow-实际使用&quot;&gt;&lt;a href=&quot;#Git-Flow-实际使用&quot; class=&quot;headerlink&quot; title=&quot;Git Flow 实际使用&quot;&gt;&lt;/a&gt;Git Flow 实际使用&lt;/h1&gt;&lt;p&gt;日常开发中，使用SourceTree来操作Git居多。SourceTree中自带Git 工作流模型，简单的使用只需要点击应用即可。&lt;br&gt;&lt;img src=&quot;http://7xno6f.com1.z0.glb.clouddn.com/blog-GitFlow26571850-6A6C-4863-80CF-1E2706FD846A.png&quot; alt=&quot;SourceTree 自带工作流&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然这边也可以进行自定义，或者说不使用这个模型，自己通过新建分支来实现Git Flow。&lt;br&gt;我实际运用中，大致是这样的：&lt;br&gt;&lt;img src=&quot;http://7xno6f.com1.z0.glb.clouddn.com/blog-GitFlowA73C5C4C-5ADD-4044-908C-D0C659C26440.png&quot; alt=&quot;利用group&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;心得&quot;&gt;&lt;a href=&quot;#心得&quot; class=&quot;headerlink&quot; title=&quot;心得&quot;&gt;&lt;/a&gt;心得&lt;/h1&gt;&lt;p&gt;1.dev有更新时，feature分支及时rebase（变基，衍合），不然当合并该feature时可能会出现很多冲突（Q_A_Q）。&lt;br&gt;2.可以复用页面的一些功能模块应该分配给同一个开发去做，不然在页面复用上会有问题。因为每个feature是分割开的。&lt;/p&gt;
&lt;h1 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h1&gt;&lt;p&gt;1.基于git的源代码管理模型——git flow &lt;a href=&quot;http://www.ituring.com.cn/article/56870&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ituring.com.cn/article/56870&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;又是一段时间没写博客了。。一直生活在甲方的世界里。。。可能也是自己懒癌复发了吧。。&lt;br&gt;ps:图片无法显示请点击：&lt;a href=&quot;http://www.jianshu.com/p/c9d7e16744e0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="Git" scheme="/tags/Git/"/>
    
      <category term="SourceTree" scheme="/tags/SourceTree/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 三大新特性</title>
    <link href="/2015/11/22/Objective-C-%E4%B8%89%E5%A4%A7%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>/2015/11/22/Objective-C-三大新特性/</id>
    <published>2015-11-22T14:34:39.000Z</published>
    <updated>2016-05-02T02:09:28.000Z</updated>
    
    <content type="html">&lt;p&gt;2015年的 WWDC 中介绍了几个 Objective-C 语言的新特性，有新特性，那么我们就去了解它们下吧。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Nullability&quot;&gt;&lt;a href=&quot;#Nullability&quot; class=&quot;headerlink&quot; title=&quot;Nullability&quot;&gt;&lt;/a&gt;Nullability&lt;/h1&gt;&lt;p&gt;Nullability其实在Xcode6.3里就已经出现了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@property (nonatomic, copy, nonnull) NSString *str;
@property (nonatomic, copy, readonly, nullable) NSArray *arr;
+ (nullable NSString *)confirmWithString:(nonnull NSString *)str;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的两个属性和一个方法的声明中添加了 &lt;code&gt;nonnull&lt;/code&gt; 和 &lt;code&gt;nullable&lt;/code&gt; ,很明显，前者是不可空，后者是可空的意思。&lt;br&gt;当然在给变量添加修饰时，就能在前面加上两个下划线了，就如   &lt;code&gt; __nullable &lt;/code&gt; 一样。例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface TestClass() {
   NSString * __nullable str;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除此之外还有一个 &lt;code&gt;null_resettable&lt;/code&gt; ,它意思是setter nullable，但是 getter nonnull。简单来说就是可以赋值为nil，但是你获取的值必定不是nil。&lt;/p&gt;
&lt;p&gt;在代码里重复写nonnull一定是一件非常蛋疼的事情，毕竟coding的原则是DRY，所以 &lt;code&gt; NS_ASSUME_NONNULL_BEGIN &lt;/code&gt; , &lt;code&gt; NS_ASSUME_NONNULL_END &lt;/code&gt; 这对宏就出现了。它的意思是把它们之间的对象都设置为nonnull，如果是nullable，那么我们得显式声明下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NS_ASSUME_NONNULL_BEGIN
@interface TestClass : NSObject
@property (nonatomic, copy, nullable) NSString *str;
@property (nonatomic, copy) NSArray *arr;
- (nullable NSString *)getString;
@end
NS_ASSUME_NONNULL_END
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Nullability 在编译器层面提供了空值的类型检查，在类型不符时给出 warning，方便开发者第一时间发现潜在问题。不过我想更大的意义在于能够更加清楚的描述接口，是主调者和被调者间的一个协议，比多少句文档描述都来得清晰。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Lightweight-Generics&quot;&gt;&lt;a href=&quot;#Lightweight-Generics&quot; class=&quot;headerlink&quot; title=&quot;Lightweight Generics&quot;&gt;&lt;/a&gt;Lightweight Generics&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Lightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（llvm 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到上面对 Lightweight Generics 的描述，是不是特别爽，以后可以用泛型拉！泛型拉！！泛型拉！！！因为之前学过用C#写web，超级享受泛型带来的代码智能提醒。那么Objective-C的泛型会不会带来这种体验，Let’s try it！&lt;/p&gt;
&lt;p&gt;类ClassOne&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface ClassOne : NSObject
@property (nonatomic, copy) NSString *classOneDes;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ViewController&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface ViewController ()
@property (nonatomic, strong) NSMutableArray&amp;lt;ClassOne *&amp;gt; *testArr;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://i5.tietuku.com/2c321fc78fe04018.jpg&quot; alt=&quot;智能提醒&quot;&gt;&lt;/p&gt;
&lt;p&gt;竟然真的支持智能提醒！！爽的不要不要的。再也不用担心强转了！！！！&lt;/p&gt;
&lt;p&gt;竟然在取值有智能提醒了，那么在赋值时，会不会有提醒呢？仍旧是上面的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self.testArr addObject:&amp;lt;#(nonnull ClassOne *)#&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;提示我们 &lt;code&gt;self.testArr&lt;/code&gt;中必须是添加一个 &lt;code&gt;ClassOne&lt;/code&gt;对象。假设我们添加一个NSString：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self.testArr addObject:@&amp;quot;1&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着，编译器出现警告啦。&lt;br&gt;&lt;img src=&quot;http://i12.tietuku.com/3fdc5654795063d3.jpg&quot; alt=&quot;警告&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实泛型和之前的 Nullability最重要的作用是丰富了接口描述信息，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@property (readonly) NSArray&amp;lt;NSString *&amp;gt; *imageURLs;
@property (readonly) NSArray&amp;lt;NSURL *&amp;gt; *avatarURLs;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就可以描述清楚 imageURLs 存的是NSString，而 avatarURLs 存的则是 NSURL 。&lt;/p&gt;
&lt;p&gt;在Objective-C中常用的容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了。那么我们是否可以自定义泛型类呢？？？try try try。&lt;/p&gt;
&lt;p&gt;我们先看一下NSArray的头文件定义的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @interface NSArray&amp;lt;__covariant ObjectType&amp;gt; : NSObject &amp;lt;NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration&amp;gt;

 @property (readonly) NSUInteger count;
 - (ObjectType)objectAtIndex:(NSUInteger)index;
 - (instancetype)init NS_DESIGNATED_INITIALIZER;
 - (instancetype)initWithObjects:(const ObjectType [])objects count:(NSUInteger)cnt NS_DESIGNATED_INITIALIZER;
 - (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;NSArray的头文件中，多了一个 ObjectType ，从字面意思来讲是&lt;strong&gt;对象类型&lt;/strong&gt;，在NSArray中声明的方法中也使用到了 ObjectType ，猜测它的作用类似C#泛型中的 &lt;strong&gt;T&lt;/strong&gt; 。&lt;br&gt;那么我们来验证下，按照NSArray的定义方式来自定义一个容器类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface Container &amp;lt;ObjectType&amp;gt; : NSObject
- (void)pushObject:(ObjectType)object;
- (ObjectType)popObject;
@property (nonatomic, readonly) NSArray&amp;lt;ObjectType&amp;gt; *allObjects;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义这样一个头文件，并实现。然后我们尝试使用这个自定义泛型类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface ViewController ()
@property (nonatomic, strong) Contanier&amp;lt;NSString *&amp;gt; *contanier;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://i5.tietuku.com/ad95ccf490d0adad.jpg&quot; alt=&quot;哇塞，可以，可以&quot;&gt;&lt;/p&gt;
&lt;p&gt;的确，可以实现自定义泛型，具体的使用，大家可以尝试下。&lt;br&gt;自定义泛型类中的 ObjectType 在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型。&lt;/p&gt;
&lt;p&gt;大家一定看到了 NSArray 的头文件中ObjectType前面有一个 &lt;code&gt; __covariant &lt;/code&gt; 修饰符，那么这个是什么意思呢？&lt;br&gt;不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了：&lt;/p&gt;
&lt;h3 id=&quot;协变性&quot;&gt;&lt;a href=&quot;#协变性&quot; class=&quot;headerlink&quot; title=&quot;协变性&quot;&gt;&lt;/a&gt;协变性&lt;/h3&gt;&lt;p&gt;__covariant - 协变性，子类型可以强转到父类型。&lt;/p&gt;
&lt;h3 id=&quot;逆变性&quot;&gt;&lt;a href=&quot;#逆变性&quot; class=&quot;headerlink&quot; title=&quot;逆变性&quot;&gt;&lt;/a&gt;逆变性&lt;/h3&gt;&lt;p&gt;__contravariant - 逆变性，父类型可以强转到子类型。&lt;/p&gt;
&lt;p&gt;协变性用的比较多，例如将 NSArray &lt;nsstring *=&quot;&quot;&gt; &lt;em&gt; 类型的对象赋值给 NSArray &lt;/em&gt; ，假设不设置NSArray泛型的协变性那将会导致警告。当然NSArray泛型带有协变性，所以这样转换是没有问题的。&lt;/nsstring&gt;&lt;/p&gt;
&lt;p&gt;那么逆变性呢？将一个父类型转换成子类型。这是一个具有风险的事情。比如 你将一个NSArray &lt;em&gt; 的对象赋值给NSArray&amp;lt;NSNumber &lt;/em&gt;&amp;gt; * 对象，很明显，前者的对象中可能是 NSString 类型，这时如果设置具有逆变性，那么赋值将会出现问题。&lt;/p&gt;
&lt;p&gt;所以逆变性慎用！！！&lt;/p&gt;
&lt;h1 id=&quot;kindof&quot;&gt;&lt;a href=&quot;#kindof&quot; class=&quot;headerlink&quot; title=&quot; __kindof &quot;&gt;&lt;/a&gt;&lt;code&gt; __kindof &lt;/code&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&lt;strong&gt;kindof&lt;/strong&gt;&lt;/code&gt; 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说：&lt;br&gt;&lt;code&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;br&gt;使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 kindof 关键字解决了这个问题：&lt;br&gt;&lt;code&gt;- (__kindof UITableViewCell &lt;em&gt;)dequeueReusableCellWithIdentifier:(NSString &lt;/em&gt;)identifier;&lt;/code&gt;&lt;br&gt;既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：&lt;br&gt;&lt;code&gt;@property (nonatomic, readonly, copy) NSArray &lt;em&gt;subviews;&lt;/em&gt;&lt;/code&gt;&lt;br&gt;这样，写下面的代码时就没有任何警告了：&lt;br&gt;&lt;code&gt;&lt;br&gt;UIButton button = view.subviews.lastObject;&lt;br&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20150615/12148.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cocoachina.com/ios/20150615/12148.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/dd799517.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://msdn.microsoft.com/zh-cn/library/dd799517.aspx&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;2015年的 WWDC 中介绍了几个 Objective-C 语言的新特性，有新特性，那么我们就去了解它们下吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="Objective-C" scheme="/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs&amp;Socket.io实现简单的服务器反推</title>
    <link href="/2015/11/17/Nodejs-Socket-io%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8D%E6%8E%A8/"/>
    <id>/2015/11/17/Nodejs-Socket-io实现服务器反推/</id>
    <published>2015-11-17T12:34:31.000Z</published>
    <updated>2016-05-02T02:51:06.000Z</updated>
    
    <content type="html">&lt;p&gt;期末临近，由于课程设计需要做一个匿名投票，签到的功能，打算通过Nodejs&amp;amp;socket.io来简单地实现长连接。第一篇技术相关，有点小激动。。。&lt;/p&gt;
&lt;h1 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=&quot;headerlink&quot; title=&quot;安装环境&quot;&gt;&lt;/a&gt;安装环境&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Nodejs的环境十分简单，从&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nodejs.org/en/&lt;/a&gt;下载pkg，然后一路next。搞定后打开Terminal，输入&lt;code&gt;node -v&lt;/code&gt;,查看Nodejs版本。&lt;/li&gt;
&lt;li&gt;安装模块，例如安装express模块，则在Terminal中输入&lt;code&gt;npm install express &lt;/code&gt;（npm：node package manage），这是在当前路径下安装模块，如果要安装全局模块，则需要执行&lt;code&gt;npm install -g express&lt;/code&gt;,卸载模块则是&lt;code&gt;npm uninstall express&lt;/code&gt;。操作起来十分方便。通过&lt;code&gt;npm list&lt;/code&gt;可以查看当前所安装的模块。&lt;/li&gt;
&lt;li&gt;既然是基于socket.io，那当然得安装socket.io模块。&lt;code&gt;npm install socket.io&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;socket-io简单介绍&quot;&gt;&lt;a href=&quot;#socket-io简单介绍&quot; class=&quot;headerlink&quot; title=&quot;socket.io简单介绍&quot;&gt;&lt;/a&gt;socket.io简单介绍&lt;/h1&gt;&lt;p&gt;   在使用Node的http模块创建服务器同时还要Express应用，因为这个服务器对象需要同时充当Express服务和Socket.io服务。可以通过如下代码创建一个socket监听。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; http    = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;http&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; express = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;express&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; socket  = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;socket.io&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; app     = express(); &lt;span class=&quot;comment&quot;&gt;//express实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; server  = http.createServer(app);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server.listen(&lt;span class=&quot;number&quot;&gt;3700&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; &lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;监听端口3700&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; io      = socket.listen(server);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就这样就可以创建一个监听localhost:3700的应用了。&lt;br&gt;在后面接着输入这一部分代码，就可以接收到get请求了。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; app.get(&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;req,res&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Get请求一次&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   res.send(&lt;span class=&quot;string&quot;&gt;&#39;你好&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然post也是可以的，&lt;code&gt;app.post()&lt;/code&gt;就可以了。&lt;br&gt;关于Nodejs和express的基本用法，大家都可以在搜索引擎中搜索到。&lt;br&gt;socket.io模块相关文档可以到&lt;a href=&quot;http://socket.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;socket.io&lt;/a&gt;上查看。&lt;/p&gt;
&lt;p&gt;接下来讲讲签到的需求。场景：会议开始，用户扫码签到，每当一个用户签到完成，所有参加同一个会议的客户端UI当前在线人数进行更新。&lt;br&gt;然后分析下整个过程主要可以分成那几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;扫码之前，用户发起请求，建立Websocket连接，利用socket.io的房间功能，将每一个会议设置为一个房间，相关的用户加入相关的房间。&lt;/li&gt;
&lt;li&gt;用户扫码进行签到，发起一个post请求，服务端接收post请求后，对数据库（mysql）进行操作，然后返回结果，同时通过socket.io反推客户端当前在线人数。&lt;/li&gt;
&lt;li&gt;客户端（iOS）对相关事件进行监听，事件触发时，刷新相关UI。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分析完成，那就先开始实现服务端吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先像之前一个，通过express和socket.io创建一个服务监听相应端口，然后通过io监听connection事件。&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//会议相关socket服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;io.of(&lt;span class=&quot;string&quot;&gt;&#39;/meeting&#39;&lt;/span&gt;).on(&lt;span class=&quot;string&quot;&gt;&#39;connection&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;socket&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;一个客户端已连接meeting&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    socket.emit(&lt;span class=&quot;string&quot;&gt;&#39;message&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;成功连接&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//进入会议室&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    socket.on(&lt;span class=&quot;string&quot;&gt;&#39;comeInMeeting&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        socket.name = obj.userID; &lt;span class=&quot;comment&quot;&gt;//socketName 设置为userID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; roomName = obj.meetingID;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        socket.join(roomName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj.userID+&lt;span class=&quot;string&quot;&gt;&#39;进入会议室&#39;&lt;/span&gt;+obj.meetingID);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        socket.emit(&lt;span class=&quot;string&quot;&gt;&quot;comeInMeeting&quot;&lt;/span&gt;,&amp;#123;code:&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//离开会议室&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    socket.on(&lt;span class=&quot;string&quot;&gt;&#39;comeOutMeeting&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        socket.leave(obj.meetingID);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(socket.name+&lt;span class=&quot;string&quot;&gt;&#39;离开会议室内&#39;&lt;/span&gt;+obj.meetingID);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    socket.on(&lt;span class=&quot;string&quot;&gt;&#39;message&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;用户发了一个消息&#39;&lt;/span&gt;+obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上用到了命名空间(&lt;code&gt;of(‘/meeting’)&lt;/code&gt;)，相关知识，可以查看搜索引擎。通过&lt;code&gt;socket.join()&lt;/code&gt;可以加入一个房间。&lt;code&gt;socket.leave()&lt;/code&gt;离开一个房间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接下来添加一个post请求处理函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;app.post(&lt;span class=&quot;string&quot;&gt;&#39;/conferenceRegister&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;req,res&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    req.on(&lt;span class=&quot;string&quot;&gt;&#39;data&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;.parse(data.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//sqlOperation为自己写的操作数据库模块 暂时可以忽略  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   sqlOperation.meetingRegistration(obj.userID,obj.meetingID,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;签到成功&quot;&lt;/span&gt;+result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (result.result == &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; roomName = obj.meetingID;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//广播当前已签到人数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                io.of(&lt;span class=&quot;string&quot;&gt;&#39;/meeting&#39;&lt;/span&gt;).sockets[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].to(roomName).emit(&lt;span class=&quot;string&quot;&gt;&#39;meetingRegisterNum&#39;&lt;/span&gt;, &amp;#123;registerNum:result.data.OnlineCountNum&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res.send(result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;签到失败&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res.send(result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中的数据库操作部分暂且忽略。&lt;code&gt;io.of(‘/meeting’).sockets[0].to(roomName).emit(‘meetingRegisterNum’, {registerNum:result.data.OnlineCountNum});&lt;/code&gt;此处也是由于添加了命名空间，所以有&lt;code&gt;of(‘/meeting’)&lt;/code&gt;。socket.io的广播方法有很多，socket.to只是其中一种，但是我尝试其他的方法和命名空间配合使用，都无法像客户端推送数据。&lt;em&gt;望大神帮忙解决！！！&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;服务端解决了（虽然实际花了很多时间QAQ），然后就是客户端了。iOS的socket.io Client 是swift语言编写的，在&lt;a href=&quot;https://github.com/socketio/socket.io-client-swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/socketio/socket.io-client-swift&lt;/a&gt;clone下来，当然可以直接用CocoaPods&lt;code&gt;pod ‘Socket.IO-Client-Swift’, ‘~&amp;gt; 4.1.2’&lt;/code&gt;。通过&lt;code&gt;#import “&amp;lt;#项目名#&amp;gt;-Swift.h”&lt;/code&gt;导入项目。因为我用的是OC，所以需要在引用文件名后加上Swift,使用桥接文件，这个桥接文件默认编译器会自动生成。&lt;br&gt;接下来的工作就很简单了，跟服务端差不多的操作。进入页面，在ViewDidLoad的时候实例化socket.io。然后添加命名空间，最后进行连接。具体代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;socketDemo-Swift.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface IndexViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property(nonatomic,strong)    SocketIOClient* socket;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation IndexViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     self.socket = [[SocketIOClient alloc] initWithSocketURL:@&amp;quot;http://localhost:3700&amp;quot; opts:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.socket joinNamespace:@&amp;quot;/meeting&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.socket on:@&amp;quot;connect&amp;quot; callback:^(NSArray* data, SocketAckEmitter* ack) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;socket connected&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.socket connect];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.socket on:@&amp;quot;message&amp;quot; callback:^(NSArray* data, SocketAckEmitter* ack) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIAlertView *alert=[[UIAlertView alloc] initWithTitle:@&amp;quot;dsd&amp;quot; message:@&amp;quot;socket连接&amp;quot; delegate:self cancelButtonTitle:@&amp;quot;queren&amp;quot; otherButtonTitles:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [alert show];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;添加一个点击方法来触发服务端的comeInMeeting事件，然后再添加监听meetingRegisterNum事件，来刷新UI。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)clickButton:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.socket emit:@&amp;quot;comeInMeeting&amp;quot; withItems:@[@&amp;#123;@&amp;quot;meetingID&amp;quot;:@&amp;quot;f9a893a94d1c1225014d1c5620bc0200&amp;quot;,@&amp;quot;userID&amp;quot;:@&amp;quot;f9a893a94d1c1225014d1c5620bc0999&amp;quot;&amp;#125;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.socket on:@&amp;quot;comeInMeeting&amp;quot; callback:^(NSArray *data,SocketAckEmitter* ack)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;socket1 进入会议&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.socket on:@&amp;quot;meetingRegisterNum&amp;quot; callback:^(NSArray *data,SocketAckEmitter* ack)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIAlertView *alert=[[UIAlertView alloc] initWithTitle:@&amp;quot;dsd&amp;quot; message:@&amp;quot;socket接收到在线人数&amp;quot; delegate:self cancelButtonTitle:@&amp;quot;queren&amp;quot; otherButtonTitles:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [alert show];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样点击按钮之后就可以加入服务端对应的房间中，当同一房间中有人进行签到，则会收到最新的在线人数。&lt;/p&gt;
&lt;p&gt;其中的post请求部分未涉及，由于是demo，所以我是通过火狐的poster来发起post请求的。&lt;/p&gt;
&lt;p&gt;差不多就这些步骤，新手接触Nodejs，只是用到了冰山一角，希望有Node大神指导。&lt;/p&gt;
&lt;h1 id=&quot;webStorm的配置&quot;&gt;&lt;a href=&quot;#webStorm的配置&quot; class=&quot;headerlink&quot; title=&quot;webStorm的配置&quot;&gt;&lt;/a&gt;webStorm的配置&lt;/h1&gt;&lt;p&gt;我尝试了下用WebStorm来写Nodejs程序，通过一些配置，可以实现所有引用框架的智能提醒。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先点击WebStrom 的设置按钮，弹出设置页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i12.tietuku.com/66169131d341b02c.jpg&quot; alt=&quot;点击设置按钮&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择右侧菜单的languages&amp;amp;frameWorks–&amp;gt;libraries,就会看到如下界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/74311666jw1ey53q0ib1uj21kw10xq9i.jpg&quot; alt=&quot;点击libraries&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;看到了很多选项，然后点击download按钮，可以看到如下图，上面可以选择下载很多配置文件（用来实现智能提醒的）。其中的TypeScript中的配置文件都是一些第三方的智能提醒，以上我们用到的express和socket.io都在这里面。&lt;br&gt;&lt;img src=&quot;http://i12.tietuku.com/2f3f36e8c51a9590.jpg&quot; alt=&quot;点击download&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果说我们再typeScript中选中文件点击Download and install ，那么你中招啦。等上半小时也不会下载完成。那么具体原因呢？&lt;a href=&quot;&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;咦才那么一点点？按照视频的操作，可以下拉那个“Official libraries”，切换到“TypeScript community stubs”，就会出现很多很多东东。然后你做了，然后即使等半小时，也是空空如也！！怒了，是被墙了吗？？我抓了一下包，神奇的，如果是Official libraries，会去亚马逊云上取xml数据，但是这个TypeScript community stubs却不会触发网络活动，神奇了！！难道是我用的daoban的原因？？不得而知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知道原因了，那么我们直接去对应git clone相应配置文件就好啦。例如我们去git上将express的配置文件&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/express/express.d.ts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt;下来。然后放在一个安全的目录下，不要丢桌面，不小心删了就没啦。（我是放在了webstorm的包文件夹内，生死共存亡）。然后就是回到原来的界面咯。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如下图，回到刚才的界面，不选择download，选择add，然后自己取一个名字，添加刚才git上搞下来的.d.ts文件，然后点击ok—&amp;gt;apply，最后神奇的发现，真的能提醒我express相关方法啦！！！&lt;br&gt;&lt;img src=&quot;http://i5.tietuku.com/f28a202b1958a8ab.jpg&quot; alt=&quot;不要点download。。点击Add&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;期末临近，由于课程设计需要做一个匿名投票，签到的功能，打算通过Nodejs&amp;amp;socket.io来简单地实现长连接。第一篇技术相关，有点小激动。。。&lt;/p&gt;
&lt;h1 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="Node.js" scheme="/tags/Node-js/"/>
    
      <category term="Socket.io" scheme="/tags/Socket-io/"/>
    
  </entry>
  
  <entry>
    <title>My first blog</title>
    <link href="/2015/11/15/MyFirstBlog/"/>
    <id>/2015/11/15/MyFirstBlog/</id>
    <published>2015-11-14T18:54:24.000Z</published>
    <updated>2016-05-02T02:34:25.000Z</updated>
    
    <content type="html">&lt;p&gt;奋战了大半天，终于搭好了这个Blog。&lt;br&gt;用的是基于Nodejs的Hexo框架，使用了它的NexT主题。本机之前搭过Nodejs的环境，所以对于安装Hexo来说比较方便的。在搭建的过程中当然遇到了很多坑，但是搜索引擎可以轻松解决掉。下面是我在搭建过程中参考的一些blog和教程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://theme-next.iissnan.com/five-minutes-setup.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://theme-next.iissnan.com/five-minutes-setup.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/739bf1305e66&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/739bf1305e66&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然用了Hexo，当然要用MarkDown啦。新手学习感觉可以找可视化编辑器来用。其中简书网页版中带的可视化编辑器可以用，当然也可以本地下载编辑器咯。&lt;/p&gt;
&lt;p&gt;—————END—————–&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;奋战了大半天，终于搭好了这个Blog。&lt;br&gt;用的是基于Nodejs的Hexo框架，使用了它的NexT主题。本机之前搭过Nodejs的环境，所以对于安装Hexo来说比较方便的。在搭建的过程中当然遇到了很多坑，但是搜索引擎可以轻松解决掉。下面是我在搭建过程中参考的一些blog
    
    </summary>
    
    
      <category term="码字" scheme="/tags/%E7%A0%81%E5%AD%97/"/>
    
  </entry>
  
</feed>
